//@version=5
// TODO: Identify bounce off confirm

// TODO: Create dynamic pivots based on ER/pivots. Check if pivot is close to other pivots

// TODO: Improve buy and sell entry to consider if too much chop (a lot of cross on main/signal lines)

// TODO: ATR + cross is buy/sell

// TODO: Disable certain instruments based on time

// TODO: Look at HMA for confirm line

// FEATURE: Supertrend

// FEATURE: DRSI and cross of UVXY

// FEATURE: Orderflow oscilator

// FEATURE: ATR


// ********** BASE SETUP **********
indicator("Trading Levels Assistant", max_labels_count = 500, max_lines_count = 500, overlay=true)

// ********** INPUTS **********

// Define input for ticker
sym1 = input.symbol("CME_MINI:MNQ1!", "Ticker 1", group="Tickers")
sym2 = input.symbol("AMEX:SPY", "Ticker 2", group="Tickers")

// Define input for pivots
sym1Pivots = input("", title="Pivot", group="Ticker 1 Levels (comma delimited)", inline="line1")
sym1BuyLevels = input("", title="  |  Buy", group="Ticker 1 Levels (comma delimited)", inline="line1")
sym1SellLevels = input("", title="Sell ", group="Ticker 1 Levels (comma delimited)", inline="line2")
sym1IntraDayLevels  = input("", title="  |  Intraday", group="Ticker 1 Levels (comma delimited)", inline="line2")
sym2Pivots = input("", title="Pivot", group="Ticker 2 Levels (comma delimited)", inline="line1")
sym2BuyLevels = input("", title="  |  Buy", group="Ticker 2 Levels (comma delimited)", inline="line1")
sym2SellLevels = input("", title="Sell ", group="Ticker 2 Levels (comma delimited)", inline="line2")
sym2IntraDayLevels  = input("", title="  |  Intraday", group="Ticker 2 Levels (comma delimited)", inline="line2")

// Define input for line settings
pivotsColor = input.color(color.purple, title="Pivot Color", group="Level Settings", inline = "pivots")
pivotsLabel = input("Pivot", title="Pivots Label", group="Level Settings", inline = "pivots")
pivotsWidth = input(2, title="    └ Pivots Width", group="Level Settings", inline = "pwidth")

buyColor = input.color(color.rgb(9, 122, 5), title="Buy Level Color", group="Level Settings", inline = "buy")
buyLabel = input("Buy", title="Buy Level Label", group="Level Settings", inline = "buy")
buyWidth = input(2, title="    └ Buy Level Width", group="Level Settings", inline = "bwidth")

sellColor = input.color(color.rgb(161, 33, 33), title="Sell Level  Color", group="Level Settings", inline = "sell")
sellLabel = input("Sell", title="Sell Level Label", group="Level Settings", inline = "sell")
sellWidth = input(2, title="    └ Sell Level Width", group="Level Settings", inline = "swidth")

intraColor = input.color(color.orange, title="Intraday Color", group="Level Settings", inline = "intra")
intraLabel = input("Intra", title="Intraday Label", group="Level Settings", inline = "intra")
intraWidth = input(2, title="    └ Intraday Width", group="Level Settings", inline = "iwidth")

labelOffset = input(15, title="Label Offset", group="General")
buffer = input.float(25.0, title="Level Bounce Buffer [H-L] (%)", group="General", minval=0, maxval=100) // Define a buffer to avoid false positives due to noise
buySellBuffer = input.float(20, title="Buy/Sell Buffer [0.001x%]", group="General",minval=0, maxval=1000) 
reversalOffset = input.float(10, title="Reversal Buffer [0.001x%]", group="General",minval=0, maxval=1000) 
lowerTF = input.int(3, title="MA Timeframe [min]", group="General",minval=0, maxval=10) 

crossLookbackTime = input.int(12, title="Crossover Lookback Timeframe [min]", group="General",minval=3, maxval=30) 
bounceLookbackTime = input.int(12, title="Bounce Lookback Timeframe [min]", group="General",minval=3, maxval=30)  
showAllConditions = input(false, title="Show Conditions for Entry", group = "General")
showBuySellLevels = input(true, title="Show Buy/Sell Text| ", group = "General")
showBuySellMarkers = input(false, title="Show Buy/Sell Marker | ", group = "General", inline = "marker")
tpLevel = input(60, title="Take Profit (ticks)", group = "General", inline = "marker")
slLevel = input(60, title="        └ Stop Loss (ticks)", group = "General", inline = "marker2")

showPivotsBounce = input(true, title=" Show Pivot Level Bounce Symbol   |   ", group="Level Bounce (Pivot)", inline="alert")
alertPivotsBounce = input(true, title="Alert on Pivot Bounce", group="Level Bounce (Pivot)",inline="alert")
includeTrigPivots = input(true, title="Trigger Buy/Sell   |   ", group="Level Bounce (Pivot)", inline="pivot")
includeRevPivots = input(true, title="Trigger Reversal", group="Level Bounce (Pivot)", inline="pivot")

showBuyBounce = input(true, title=" Show Buy Level Bounce Symbol   |   ", group="Level Bounce (Buy)", inline="alert")
alertBuyBounce = input(true, title="Alert on Buy Bounce", group="Level Bounce (Buy)",inline="alert")
includeTrigBuy = input(true, title="Trigger Buy/Sell   |   ", group="Level Bounce (Buy)", inline="Buy")
includeRevBuy = input(true, title="Trigger Reversal", group="Level Bounce (Buy)", inline="Buy")

showSellBounce = input(true, title=" Show Sell Level Bounce Symbol   |   ", group="Level Bounce (Sell)", inline="alert")
alertSellBounce = input(true, title="Alert on Sell Bounce", group="Level Bounce (Sell)",inline="alert")
includeTrigSell = input(true, title="Trigger Buy/Sell   |   ", group="Level Bounce (Sell)", inline="Sell")
includeRevSell = input(true, title="Trigger Reversal", group="Level Bounce (Sell)", inline="Sell")

showIntraBounce = input(true, title=" Show Intra Level Bounce Symbol   |   ", group="Level Bounce (Intra)", inline="alert")
alertIntraBounce = input(true, title="Alert on Intra Bounce", group="Level Bounce (Intra)",inline="alert")
includeTrigIntra = input(true, title="Trigger Buy/Sell   |   ", group="Level Bounce (Intra)", inline="Intra")
includeRevIntra = input(true, title="Trigger Reversal", group="Level Bounce (Intra)", inline="Intra")

// ATR
showATRArrow = input(true, title="Show ATR Arrow", group="ATR")
atrArrowTransparency = input.int(20, title="    └ ATR Arrow Transparency", group="ATR", minval=0, maxval=100)
showATRDots = input(true, title="Show ATR Dots", group="ATR", inline="main")
atrDotTransparency = input.int(80, title="    └ ATR Dot Transparency", group="ATR", minval=0, maxval=100)
buyATRColor = input(color.rgb(20, 161, 44), title="Buy ATR Color", group="ATR", inline="color")
sellATRColor = input(color.rgb(133, 0, 55), title="   |   Sell ATR Color", group="ATR", inline="color")

// Define EMA/SMA settings
periodFastMA = input(8, title="Fast MA Period", group="Moving Averages", inline="fast")
colorFastMA = input.color(color.new(color.fuchsia,50), title="Fast MA Color", group="Moving Averages", inline="fast")
typeFastMA = input.string("EMA", title="    └ Fast MA Type", options=["EMA", "SMA"], group="Moving Averages", inline="tfast")

periodSlowMA = input(13, title="Slow MA Period", group="Moving Averages", inline="slow")
colorSlowMA = input.color(color.new(color.green,50), title="Slow MA Color", group="Moving Averages", inline="slow")
typeSlowMA = input.string("EMA", title="    └ Slow MA Type", options=["EMA", "SMA"], group="Moving Averages", inline="tslow")

periodStableMA = input(21, title="Stable MA Period", group="Moving Averages", inline="Stable")
colorStableMA = input.color(color.new(color.red,50), title="Stable MA Color", group="Moving Averages", inline="Stable")
typeStableMA = input.string("EMA", title="    └ Stable MA Type", options=["EMA", "SMA"], group="Moving Averages", inline="tStable")

showConfirmMA = input(true, title="Show Confirm MA   |   ", group="Moving Averages", inline="confirm")
confirmMASmoothPeriod = input(3, title="Confirm MA Smooth Period", group="Moving Averages", inline="confirm")

alertDirectionalBuySell = input(true, title="Buy/Sell", group="Alerts", inline="main")
alertReversalBuySell = input(true, title="Buy/Sell (Reversal)", group="Alerts", inline="main")
alertCrossBuySell = input(true, title="Buy/Sell (Cross)", group="Alerts", inline="main")
alertATRArrow = input(false, title="ATR Arrow", group="Alerts", inline="ATR")

show_table      = input.bool(true,"Show Dashboard", group="Dashboard", inline="Table")
tableLocation   = input.string(defval='Bottom right', options=['Top left', 'Top center', 'Top right', 'Bottom left', 'Bottom center', 'Bottom right'], title='| Location', group="Dashboard", inline="Table")
tablePosition   = tableLocation == 'Top left' ? position.top_left : tableLocation == 'Top center' ? position.top_center : tableLocation == 'Top right' ? position.top_right : tableLocation == 'Bottom left' ? position.bottom_left : tableLocation == 'Bottom center' ? position.bottom_center : position.bottom_right
table_font_size       = input.string('Normal', "    └ Font Size", options = ['Auto', 'Tiny', 'Small', 'Normal', 'Large'], group="Dashboard", inline = 'line2')
table_bgcolor       = input.color(color.gray, title="Background Color", group="Dashboard", inline="line3")
table_fontcolor       = input.color(color.white, title="  |  Font Color", group="Dashboard", inline="line3")

timePeriod1 = input.session("1030-1615", title="Active Period 1", group="Trading Time (NY Time)")
timePeriod2 = input.session("0100-0800", title="Active Period 2", group="Trading Time (NY Time)")
timePeriod3 = input.session("1700-1715", title="Active Period 3", group="Trading Time (NY Time)")

// ********** GLOBAL VARIABLES *********
var displayTable = table.new(tablePosition, 2, 6, border_width=1, bgcolor = table_bgcolor)
var float bounceLevel = na
var int systemState = 0
var bool lastCrossDir = na
var line [] lineArray = array.new_line()
var label [] labelArray = array.new_label()
for line in lineArray
    line.delete(line)
for label in labelArray
    label.delete(label)
array.clear(lineArray)    
array.clear(labelArray)

// ********** FUNCTIONS **********
draw_line(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    dline = line.new(x1=_x1, y1=_y1, x2=_x2, y2=_y2, xloc=_xloc, extend=_extend, color=_color, style=_style, width=_width)
    array.push(lineArray,dline)

draw_label(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    dlabel = label.new(x=_x, y=_y, text=_text, xloc=_xloc, yloc=_yloc, color=_color, style=_style, textcolor=_textcolor, size=_size, textalign=_textalign, tooltip=_tooltip)

draw_buymarker(limitLevel,TP,SL) =>
    draw_label(bar_index, limitLevel, "Buy @ " + str.tostring(limitLevel), xloc.bar_index, yloc.abovebar,  color.teal, label.style_text_outline, color.white, size.small, text.align_center, '')
    draw_label(bar_index, limitLevel, "", xloc.bar_index, yloc.price,  color.teal, label.style_cross, color.white, size.tiny, text.align_center, '')
    if showBuySellMarkers
        draw_label(bar_index, limitLevel + TP, "", xloc.bar_index, yloc.price,  color.rgb(1, 221, 199), label.style_triangledown, color.white, size.tiny, text.align_center, '')
        draw_label(bar_index, limitLevel - SL, "", xloc.bar_index, yloc.price,  color.rgb(0, 56, 50), label.style_triangleup, color.white, size.tiny, text.align_center, '')
        line.new(bar_index,limitLevel + TP, bar_index, limitLevel - SL,xloc.bar_index,extend.none,color.teal,line.style_dotted,2)

draw_sellmarker(limitLevel,TP,SL) =>
    draw_label(bar_index, limitLevel, "Sell @ " + str.tostring(limitLevel), xloc.bar_index, yloc.abovebar,  color.rgb(137, 0, 0), label.style_text_outline, color.white, size.small, text.align_center, '')
    draw_label(bar_index, limitLevel, "", xloc.bar_index, yloc.price,  color.rgb(137, 0, 0), label.style_cross, color.white, size.tiny, text.align_center, '')
    if showBuySellMarkers
        draw_label(bar_index, limitLevel - TP, "", xloc.bar_index, yloc.price,  color.rgb(221, 1, 1), label.style_triangleup, color.white, size.tiny, text.align_center, '')
        draw_label(bar_index, limitLevel + SL, "", xloc.bar_index, yloc.price,  color.rgb(56, 0, 0), label.style_triangledown, color.white, size.tiny, text.align_center, '')
        line.new(bar_index,limitLevel + TP, bar_index, limitLevel - SL,xloc.bar_index,extend.none,color.rgb(137, 0, 0),line.style_dotted,2)

check_bounce_high(level) =>
    highBounce = high >= level and close < level - (high - low) * (buffer/100) and (open <= level + (high - low) * (buffer/100)) and barstate.isconfirmed

check_bounce_low(level) =>
    lowBounce = low <= level and close > level + (high - low) * (buffer/100) and (open >= level - (high - low) * (buffer/100)) and barstate.isconfirmed

check_levels_low(levels, bounceType, symbolEnabled) =>    
    plotLevels = str.split(levels, ",")
    anyBounce = false
    for level in plotLevels
        if check_bounce_low(str.tonumber(level))
            anyBounce := true
            if symbolEnabled
                draw_label(bar_index, str.tonumber(level), bounceType, xloc.bar_index, yloc.belowbar,  color.green, label.style_label_up, color.white, size.small, text.align_center, '')
    result = anyBounce

check_levels_high(levels, bounceType, symbolEnabled) =>    
    plotLevels = str.split(levels, ",")
    anyBounce = false
    for level in plotLevels
        if check_bounce_high(str.tonumber(level))
            anyBounce := true
            if symbolEnabled
                draw_label(bar_index, str.tonumber(level), bounceType, xloc.bar_index, yloc.abovebar,  color.red, label.style_label_down, color.white, size.small, text.align_center, '')
    result = anyBounce

check_optimal_level(levels, symbolEnabled) =>    
    plotLevels = str.split(levels, ",")
    optLevel = 0.0
    if symbolEnabled
        for level in plotLevels
            if math.abs(str.tonumber(level) - close) < (close * buySellBuffer/100000)
                optLevel := str.tonumber(level)
                
    result = optLevel

draw_levels(levels, color, width, label, labeloffset) =>
    plotLevels = str.split(levels, ",")
    for level in plotLevels
        draw_line(bar_index, str.tonumber(level), bar_index + labeloffset + 15, str.tonumber(level),  xloc.bar_index, extend.left, color, line.style_solid, width)
        if barstate.islast
            plot_label = label.new(bar_index + labeloffset + 10, str.tonumber(level))
            label.set_text(plot_label, label)
            label.set_style(plot_label, label.style_none)
            label.set_textcolor(plot_label, color)
            array.push(labelArray, plot_label)
    
f_fillCell(_row, _column,series string _cellText) =>
    switch table_font_size
        "Auto" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.auto)
        "Tiny" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.tiny)
        "Small" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.small)
        "Normal" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.normal)
        "Large" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.large)

f_fillCellColor(_row,_column, color) =>
    table.cell(displayTable,_column,_row, bgcolor=color)

f_fillCellColorText(_row, _column, series string _cellText, color) =>
    switch table_font_size
        "Auto" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.auto)
        "Tiny" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.tiny)
        "Small" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.small)
        "Normal" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.normal)
        "Large" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.large)

extractSymbolName(simple string sym) =>
    pos = str.pos(sym, ":")  // Get position of ":" character
    tkr= str.substring(sym, pos+1)

// Function to convert timeframe to minutes
getTimeframeInMinutes() =>
    // Initialize variable for minutes
    var float minutes = na
    // Check if timeframe is in minutes, hours, or days and convert accordingly
    if str.contains(timeframe.period, "D")
        minutes := str.tonumber(str.replace(timeframe.period, "D", "")) * 1440
    else if str.contains(timeframe.period, "H")
        minutes := str.tonumber(str.replace(timeframe.period, "H", "")) * 60
    else if str.contains(timeframe.period, "M")
        minutes := str.tonumber(str.replace(timeframe.period, "M", ""))
    else
        // Assuming direct minute timeframes like "15", "5", etc.
        minutes := str.tonumber(timeframe.period)
    // Return calculated minutes
    minutes

// Function to calculate the limit level
getLimitLevel(priceTarget, close, buyDir) =>
    limitLevel = buyDir ? math.min(priceTarget, close) : math.max(priceTarget, close)

// ********** LEVEL RENDERING **********

// Check if symbol matches the selected ticker
if ticker.standard() == sym1
    draw_levels(sym1Pivots, pivotsColor, pivotsWidth, pivotsLabel, labelOffset)
    draw_levels(sym1BuyLevels, buyColor, buyWidth, buyLabel, labelOffset)
    draw_levels(sym1SellLevels, sellColor, sellWidth, sellLabel, labelOffset)
    draw_levels(sym1IntraDayLevels, intraColor, intraWidth, intraLabel, labelOffset)

if ticker.standard() == sym2
    draw_levels(sym2Pivots, pivotsColor, pivotsWidth, pivotsLabel, labelOffset)
    draw_levels(sym2BuyLevels, buyColor, buyWidth, buyLabel, labelOffset)
    draw_levels(sym2SellLevels, sellColor, sellWidth, sellLabel, labelOffset)
    draw_levels(sym2IntraDayLevels, intraColor, intraWidth, intraLabel, labelOffset)

// ********** LEVEL BOUNCE CHECK **********
anyPivotSym1BounceUp = false
anyBuySym1BounceUp = false
anySellSym1BounceUp = false
anyIntraSym1BounceUp = false

anyPivotSym1BounceDown = false
anyBuySym1BounceDown = false
anySellSym1BounceDown = false
anyIntraSym1BounceDown = false

anyPivotSym2BounceUp = false
anyBuySym2BounceUp = false
anySellSym2BounceUp = false
anyIntraSym2BounceUp = false

anyPivotSym2BounceDown = false
anyBuySym2BounceDown = false
anySellSym2BounceDown = false
anyIntraSym2BounceDown = false

if ticker.standard() == sym1
    anyPivotSym1BounceUp := check_levels_low(sym1Pivots, pivotsLabel, showPivotsBounce)
    anyPivotSym1BounceDown := check_levels_high(sym1Pivots, pivotsLabel, showPivotsBounce)
    anyBuySym1BounceUp := check_levels_low(sym1BuyLevels, buyLabel, showBuyBounce)
    anyBuySym1BounceDown := check_levels_high(sym1BuyLevels, buyLabel, showBuyBounce)
    anySellSym1BounceUp := check_levels_low(sym1SellLevels, sellLabel, showSellBounce)
    anySellSym1BounceDown := check_levels_high(sym1SellLevels, sellLabel, showSellBounce)
    anyIntraSym1BounceUp := check_levels_low(sym1IntraDayLevels, intraLabel, showIntraBounce)
    anyIntraSym1BounceDown := check_levels_high(sym1IntraDayLevels, intraLabel, showIntraBounce)

if ticker.standard() == sym2
    anyPivotSym2BounceUp := check_levels_low(sym2Pivots, pivotsLabel, showPivotsBounce)
    anyPivotSym2BounceDown := check_levels_high(sym2Pivots, pivotsLabel, showPivotsBounce)
    anyBuySym2BounceUp := check_levels_low(sym2BuyLevels, buyLabel, showBuyBounce)
    anyBuySym2BounceDown := check_levels_high(sym2BuyLevels, buyLabel, showBuyBounce)
    anySellSym2BounceUp := check_levels_low(sym2SellLevels, sellLabel, showSellBounce)
    anySellSym2BounceDown := check_levels_high(sym2SellLevels, sellLabel, showSellBounce)
    anyIntraSym2BounceUp := check_levels_low(sym2IntraDayLevels, intraLabel, showIntraBounce)
    anyIntraSym2BounceDown := check_levels_high(sym2IntraDayLevels, intraLabel, showIntraBounce)

anyPivotSym1Bounce = anyPivotSym1BounceUp or anyPivotSym1BounceDown
anyBuySym1Bounce = anyBuySym1BounceUp or anyBuySym1BounceDown
anySellSym1Bounce = anySellSym1BounceUp or anySellSym1BounceDown
anyIntraSym1Bounce = anyIntraSym1BounceUp or anyIntraSym1BounceDown

anyPivotSym2Bounce = anyPivotSym2BounceUp or anyPivotSym2BounceDown
anyBuySym2Bounce = anyBuySym2BounceUp or anyBuySym2BounceDown
anySellSym2Bounce = anySellSym2BounceUp or anySellSym2BounceDown
anyIntraSym2Bounce = anyIntraSym2BounceUp or anyIntraSym2BounceDown

anySym1BounceUp = (anyPivotSym1BounceUp and includeTrigPivots) or (anyBuySym1BounceUp and includeTrigBuy) or (anySellSym1BounceUp and includeTrigSell) or (anyIntraSym1BounceUp and includeTrigIntra)
anySym1BounceDown = (anyPivotSym1BounceDown and includeTrigPivots) or (anyBuySym1BounceDown and includeTrigBuy) or (anySellSym1BounceDown and includeTrigSell) or (anyIntraSym1BounceDown and includeTrigIntra)

anySym2BounceUp = (anyPivotSym2BounceUp and includeTrigPivots) or (anyBuySym2BounceUp and includeTrigBuy) or (anySellSym2BounceUp and includeTrigSell) or (anyIntraSym2BounceUp and includeTrigIntra)
anySym2BounceDown = (anyPivotSym2BounceDown and includeTrigPivots) or (anyBuySym2BounceDown and includeTrigBuy) or (anySellSym2BounceDown and includeTrigSell) or (anyIntraSym2BounceDown and includeTrigIntra)

anySym1BounceUpRev = (anyPivotSym1BounceUp and includeRevPivots) or (anyBuySym1BounceUp and includeRevBuy) or (anySellSym1BounceUp and includeRevSell) or (anyIntraSym1BounceUp and includeRevIntra)
anySym1BounceDownRev = (anyPivotSym1BounceDown and includeRevPivots) or (anyBuySym1BounceDown and includeRevBuy) or (anySellSym1BounceDown and includeRevSell) or (anyIntraSym1BounceDown and includeRevIntra)

anySym2BounceUpRev = (anyPivotSym2BounceUp and includeRevPivots) or (anyBuySym2BounceUp and includeRevBuy) or (anySellSym2BounceUp and includeRevSell) or (anyIntraSym2BounceUp and includeRevIntra)
anySym2BounceDownRev = (anyPivotSym2BounceDown and includeRevPivots) or (anyBuySym2BounceDown and includeRevBuy) or (anySellSym2BounceDown and includeRevSell) or (anyIntraSym2BounceDown and includeRevIntra)

// ********** ATR RENDERING **********
dataLength = 8
atrMALength = 5
atrSmoothLength = 3
atrMultiplier = 1.0
numATR = 4
checkPastSignal = true

// ATR calculation if close is outside of ATR
[atrHMA, hl2HMA, closeHMA] = request.security(syminfo.tickerid, '', [ta.hma(ta.tr, numATR), hl2, close])

var upperATRRange = 0.0
upperATRRange := hl2HMA + atrMultiplier * atrHMA

var lowerATRRange = 0.0
lowerATRRange := hl2HMA + -atrMultiplier * atrHMA

var movingRange = 0.0

if closeHMA < movingRange[1]
    movingRange := upperATRRange
else
    movingRange := lowerATRRange

[curOpen, curClose] = request.security(syminfo.tickerid, '', [open, close])

momentum = 0
for i = 0 to dataLength by 1
    momentum += (curClose > curOpen[i] ? 1 : curClose < curOpen[i] ? -1 : 0)

// TOOD: Use momentumMA as trend calc
momentumMA = ta.ema(momentum, atrMALength)
momentumMain = ta.ema(momentumMA, atrSmoothLength)
momentumSignal = ta.ema(momentumMain, atrSmoothLength)

currentClose = request.security(syminfo.tickerid, '', close)

var buyATRSignal = false
var sellATRSignal = false

if checkPastSignal
    buyATRSignal := currentClose > movingRange and (currentClose > movingRange)[1] and (currentClose > movingRange)[2] and (currentClose > movingRange)[3] and momentumMain > momentumSignal and not (momentumMain > momentumSignal)[1]
    sellATRSignal := currentClose < movingRange and (currentClose < movingRange)[1] and (currentClose < movingRange)[2] and (currentClose < movingRange)[3] and momentumMain < momentumSignal and not (momentumMain < momentumSignal)[1]
else
    buyATRSignal := currentClose > movingRange and momentumMain > momentumSignal ? true : false
    sellATRSignal := currentClose < movingRange and momentumMain < momentumSignal ? true : false

potentialATRLongDot = checkPastSignal ? currentClose > movingRange and (currentClose > movingRange)[1] and (currentClose > movingRange)[2] and (currentClose > movingRange)[3] and momentumMain < momentumSignal : false
potentialATRShortDot = checkPastSignal ? currentClose < movingRange and (currentClose < movingRange)[1] and (currentClose < movingRange)[2] and (currentClose < movingRange)[3] and momentumMain > momentumSignal : false

// ********** ATR RENDERING **********
plotshape(showATRArrow ? buyATRSignal and not buyATRSignal[1] : na, title="ATR Long", style=shape.triangleup, color=color.new(buyATRColor, atrArrowTransparency), location=location.belowbar, size=size.small)
plotshape(showATRArrow ? sellATRSignal and not sellATRSignal[1] : na, title="ATR Short", style=shape.triangledown, color=color.new(sellATRColor, atrArrowTransparency), location=location.abovebar, size=size.small)

plotshape(showATRDots ? potentialATRLongDot : na, title="ATR Long Forming", style=shape.circle, color=color.new(buyATRColor, atrDotTransparency), location=location.belowbar, size=size.small)
plotshape(showATRDots ? potentialATRShortDot : na, title="ATR Short Forming", style=shape.circle, color=color.new(sellATRColor, atrDotTransparency), location=location.abovebar, size=size.small)

// ********** EMA RENDERING **********
fastMA = typeFastMA == "EMA" ? request.security(syminfo.tickerid, str.tostring(lowerTF), ta.ema(close, periodFastMA)) : request.security(syminfo.tickerid, str.tostring(lowerTF), ta.sma(close, periodFastMA))
slowMA = typeSlowMA == "EMA" ? request.security(syminfo.tickerid, str.tostring(lowerTF), ta.ema(close, periodSlowMA)) : request.security(syminfo.tickerid, str.tostring(lowerTF), ta.sma(close, periodSlowMA))
stableMA = typeStableMA == "EMA" ? request.security(syminfo.tickerid, str.tostring(lowerTF), ta.ema(close, periodStableMA)) : request.security(syminfo.tickerid, str.tostring(lowerTF), ta.sma(close, periodStableMA))

// ********** EMA ANALYSIS **********
fastCrossSlowUp = ta.crossover(fastMA, slowMA)
fastCrossSlowDown = ta.crossunder(fastMA, slowMA)

// Calculate differentials/deltas
maDifference = fastMA - slowMA
delta = maDifference - maDifference[1]
acceleration = delta - delta[1]

direction = math.sign(maDifference)

// Magnitude of Trend and Momentum
trendMagnitude = math.abs(maDifference)
momentumMagnitude = math.abs(delta)

// Trend calculation
// TODO: Normalise trend against range
trendDirection = direction * (trendMagnitude + momentumMagnitude + math.abs(acceleration))
trendColor = color.gray
volatileLimit = 5
trendLimit = 2.5
chopLimit = 1.5

// Set color based on trendScore
if trendDirection > volatileLimit
    trendColor := color.rgb(0, 255, 8)
else if trendDirection > trendLimit
    trendColor := color.rgb(18, 170, 23)
else if trendDirection > chopLimit
    trendColor := color.rgb(0, 102, 22)
else if trendDirection < (-1 * volatileLimit)
    trendColor := color.rgb(255, 0, 0)
else if trendDirection < (-1 * trendLimit)
    trendColor := color.rgb(175, 24, 24)
else if trendDirection < (-1 * chopLimit)
    trendColor := color.rgb(110, 3, 3)

chopDetect = trendDirection < chopLimit and trendDirection > (-1 * chopLimit)
volatileMove = trendDirection > volatileLimit or trendDirection < (-1 * volatileLimit)

// Adjust maxTrendMagnitude based on observed max values to fine-tune interpolation
maxTrendMagnitude = 5 // Example max value, adjust based on data
normalizedTrendMagnitude = math.min(trendDirection / maxTrendMagnitude, 3)

// Calculate adaptive line
// At 0 trendMagnitude, line = stableMA. At max bias, line = fastMA.
var float adaptiveLine  = na
if trendDirection > 1.5
    // Uptrend: More bias towards fastMA
    adaptiveLine  := stableMA + (fastMA - stableMA) * (2*normalizedTrendMagnitude/3) + (slowMA - stableMA) * normalizedTrendMagnitude/3
else if trendDirection < -1.5
    // Downtrend: Bias towards slowMA, but capped at stableMA
    adaptiveLine  := stableMA + (stableMA - fastMA) * (2*normalizedTrendMagnitude/3) + (stableMA - slowMA) * normalizedTrendMagnitude/3
else
    // No clear trend: Use stableMA
    adaptiveLine  := (stableMA + fastMA + slowMA)/3

if (trendDirection > 2.5) and (adaptiveLine - fastMA) > 10
    adaptiveLine := fastMA + 10
else if (trendDirection < -2.5) and (fastMA - adaptiveLine) > 10
    adaptiveLine := fastMA - 10
    
smoothConfirmMA = ta.ema(adaptiveLine, confirmMASmoothPeriod)

// Plot MAs
plot(fastMA, color=colorFastMA, title="Fast MA")
plot(slowMA, color=colorSlowMA, title="Slow MA")
plot(stableMA, color=colorStableMA, title="Balancing MA")
plot(smoothConfirmMA, title="Confirm MA", color=showConfirmMA ? trendColor : na, linewidth=2)

priceAboveConfirm = close > smoothConfirmMA
priceBelowConfirm = close < smoothConfirmMA

// **********ENTRY CONDITIONS **********
// BUG: Potential bug in the execution of this
if ticker.standard() == sym1
    priceOptimalEntryLevel1 = check_optimal_level(sym1Pivots, includeTrigPivots)
    priceOptimalEntryLevel2 = check_optimal_level(sym1BuyLevels, includeTrigBuy)
    priceOptimalEntryLevel3 = check_optimal_level(sym1SellLevels, includeTrigSell)
    priceOptimalEntryLevel4 = check_optimal_level(sym1IntraDayLevels, includeTrigIntra)
    if priceOptimalEntryLevel1 > 0
        bounceLevel := priceOptimalEntryLevel1
    if priceOptimalEntryLevel2 > 0
        bounceLevel := priceOptimalEntryLevel2
    if priceOptimalEntryLevel3 > 0
        bounceLevel := priceOptimalEntryLevel3
    if priceOptimalEntryLevel4 > 0
        bounceLevel := priceOptimalEntryLevel4

priceCandleBufferEntry = (high - low) * buffer/100
priceOptimalBufferEntry = (close) * buySellBuffer/100000
priceOptimalReversalEntry = (close) * reversalOffset/100000
priceOptimalEntryConfirm = math.abs(close - smoothConfirmMA) < (close * buySellBuffer/100000)
priceOptimalEntryLevel = math.abs(close- bounceLevel) < (close * buySellBuffer/100000)

// ********** SIGNALS **********
buySignal = false
buyReversalSignal = false
sellSignal = false
sellReversalSignal = false
buyCrossSignal = false
sellCrossSignal = false
crossSignalLookback = math.floor(crossLookbackTime / getTimeframeInMinutes())
bufferBuySellLookback = math.floor(bounceLookbackTime / getTimeframeInMinutes())

// If trend is up and we get a bounce up we have a buy directional else its reversal
if ticker.standard() == sym1
    buySignal := trendDirection >= 1 and anySym1BounceUp
    sellSignal := trendDirection <= -1 and anySym1BounceDown 
    buyReversalSignal := trendDirection <= -1 and anySym1BounceUpRev
    sellReversalSignal := trendDirection >= 1 and anySym1BounceDownRev

if ticker.standard() == sym2
    buySignal := trendDirection >= 1 and anySym2BounceUp
    sellSignal := trendDirection <= -1 and anySym2BounceDown 
    buyReversalSignal := trendDirection <= -1 and anySym2BounceUpRev
    sellReversalSignal := trendDirection >= 1 and anySym2BounceDownRev

// Look back over the last 2 bars to see if we had a trigger once we get a cross
if fastCrossSlowDown or sellATRSignal
    lastCrossDir := false
    for i = 0 to crossSignalLookback
        if anySym1BounceDown[i]
            sellCrossSignal := true

if fastCrossSlowUp or buyATRSignal
    lastCrossDir := true
    for i = 0 to crossSignalLookback
        if anySym1BounceUp[i] 
            buyCrossSignal := true

cancelSellCondition = anySym1BounceUp or fastCrossSlowUp or buyATRSignal
cancelBuyCondition = anySym1BounceDown or fastCrossSlowDown or sellATRSignal

// ********** DASHBOARD **********
ticker1_price  = request.security(sym1, timeframe.period, math.round_to_mintick(close))
ticker2_price  = request.security(sym2, timeframe.period, math.round_to_mintick(close))

if barstate.islast and show_table
    f_fillCell(0, 0, "Confirm")
    f_fillCell(1, 0, "Trend")
    f_fillCell(2, 0, extractSymbolName(sym1))
    f_fillCell(3, 0, extractSymbolName(sym2))
    f_fillCell(4, 0, "Entry")

    f_fillCellColorText(0,1,    chopDetect ? 'CHOP' : (volatileMove ? '!!!!' : ''),priceAboveConfirm ? color.rgb(0, 114, 4) : color.rgb(116, 0, 0))
    f_fillCellColorText(1, 1,  str.tostring(math.round(trendDirection,1)), trendColor)
    f_fillCell(2, 1, str.tostring(ticker1_price))
    f_fillCell(3, 1, str.tostring(ticker2_price))
    f_fillCellColorText(4, 1, str.tostring(math.round(priceOptimalBufferEntry,1)) + "/" + str.tostring(math.round(priceOptimalReversalEntry,1)), priceOptimalEntryConfirm ? color.green : color.gray)
    //TODO: Add symbol to show trend of both tickers

// ********** TRADING **********
allowedTimes() =>
    not na(time(timeframe = timeframe.period, session = timePeriod1, timezone = "America/New_York")) or not na(time(timeframe = timeframe.period, session = timePeriod2, timezone = "America/New_York")) or not na(time(timeframe = timeframe.period, session = timePeriod3, timezone = "America/New_York"))

bool validTriggerPeriod = allowedTimes()
var float limitLevel = na

buyTriggeredInLookback = false
sellTriggeredInLookback = false
systemState := 0

buyReversalCount = 0
sellReversalCount = 0

for i = 0 to bufferBuySellLookback
    if buySignal[i]
        buyTriggeredInLookback := true
    if sellSignal[i]
        sellTriggeredInLookback := true
    if buyReversalSignal[i]
        buyTriggeredInLookback := true
        buyReversalCount += 1
    if sellSignal[i] or sellReversalSignal[i]
        sellTriggeredInLookback := true
        sellReversalCount += 1

// Make sure we get the last level in the lookback for the calcs
// BUG: Pulls back the wrong level after a cross to  directionalyou
limitBounceLevel = 0.0
lastBounceDir = 0
for i = 0 to bufferBuySellLookback
    if bounceLevel[i] != limitBounceLevel and bounceLevel[i] > 0           
        if (buySignal[i] or buyReversalSignal[i] or buyCrossSignal[i])
            if lastBounceDir != -1
                limitBounceLevel := bounceLevel[i]
            lastBounceDir := 1
        else if sellSignal[i] or sellReversalSignal[i] or sellCrossSignal[i]
            if lastBounceDir != 1
                limitBounceLevel := bounceLevel[i]
            lastBounceDir := -1

// Check for cross buy/sell signals
buyCancelIndex = bufferBuySellLookback + 1
sellCancelIndex = bufferBuySellLookback + 1
for i = 0 to bufferBuySellLookback
    int revIndex = bufferBuySellLookback - i
    if cancelBuyCondition[revIndex]
        buyCancelIndex := revIndex
    if cancelSellCondition[revIndex]
        sellCancelIndex := revIndex
           
if not chopDetect
    // Check first if we have any cancels from before
    if systemState[1] > 0 and systemState[1] < 10 and cancelBuyCondition
        systemState := 0
    else if systemState[1] > 10 and cancelSellCondition
        systemState := 0
    else
        for i = 0 to bufferBuySellLookback
            int revIndex = bufferBuySellLookback - i
            if buyCrossSignal[revIndex] and lastCrossDir and buyCancelIndex > revIndex
                systemState := 3
                limitLevel := getLimitLevel(math.floor(smoothConfirmMA * (1 + buySellBuffer/100000)), close, true)
            else if sellCrossSignal[revIndex] and not lastCrossDir and sellCancelIndex > revIndex
                systemState := 13
                limitLevel := getLimitLevel(math.ceil(smoothConfirmMA * (1 - buySellBuffer/100000)), close, false)

        // Check for buy/sell signals
        if systemState == 0
            for i = 0 to bufferBuySellLookback
                int revIndex = bufferBuySellLookback - i
                if buySignal[revIndex] and not sellTriggeredInLookback and buyCancelIndex > revIndex
                    systemState := 2
                    limitLevel := getLimitLevel(math.floor(limitBounceLevel * (1 + buySellBuffer/100000)), close, true)
                else if sellSignal[revIndex] and not buyTriggeredInLookback and sellCancelIndex > revIndex
                    systemState := 12
                    limitLevel := getLimitLevel(math.ceil(limitBounceLevel * (1 - buySellBuffer/100000)), close, false)
            
        if systemState == 0
            for i = 0 to bufferBuySellLookback
                int revIndex = bufferBuySellLookback - i
                if buyReversalSignal[revIndex] and not sellTriggeredInLookback and buyCancelIndex > revIndex
                    systemState := 4
                    limitLevel := getLimitLevel(math.floor(limitBounceLevel * (1 + reversalOffset/100000)), close, true)
                else if sellReversalSignal[revIndex] and not buyTriggeredInLookback and sellCancelIndex > revIndex
                    systemState := 14
                    limitLevel := getLimitLevel(math.ceil(limitBounceLevel * (1 - reversalOffset/100000)), close, false)

buyLong = systemState == 2
buyCross = systemState == 3
buyReversal = systemState == 4
sellShort = systemState == 12
sellCross = systemState == 13
sellReversal = systemState == 14

buyReversalTrigger = buyReversal and buyReversalCount > 1
sellReversalTrigger = sellReversal and sellReversalCount > 1
// ********** RENDERING SYMBOLS **********
if showAllConditions
    if priceOptimalEntryLevel and false
        draw_label(bar_index, close, 'Optimal Level', xloc.bar_index, yloc.abovebar,  color.yellow, label.style_cross, color.white, size.small, text.align_center, '')
    if priceOptimalEntryConfirm and false
        draw_label(bar_index, close, 'Confirm Level', xloc.bar_index, yloc.abovebar,  color.maroon, label.style_cross, color.white, size.small, text.align_center, '')
    if fastCrossSlowDown 
        draw_label(bar_index, close, 'DownCross', xloc.bar_index, yloc.abovebar,  color.fuchsia, label.style_arrowdown, color.white, size.small, text.align_center, '')
    if fastCrossSlowUp 
        draw_label(bar_index, close, 'UpCross', xloc.bar_index, yloc.belowbar,  color.aqua, label.style_arrowup, color.white, size.small, text.align_center, '')

TP = tpLevel * syminfo.mintick
SL = slLevel * syminfo.mintick

if validTriggerPeriod
    if (systemState != systemState[1] and systemState[1] > 0 and systemState > 0 and ((systemState < 10 and systemState[1] > 10) or (systemState > 10 and systemState[1] < 10))) or (systemState[1] > 0 and systemState == 0 and (cancelBuyCondition or cancelSellCondition))
        if showBuySellLevels
            draw_label(bar_index, limitLevel, "Close Position: " + str.tostring(systemState[1]) + "->" + str.tostring(systemState), xloc.bar_index, yloc.abovebar,  color.rgb(110, 0, 137), label.style_text_outline, color.white, size.small, text.align_center, '')
            draw_label(bar_index, close, str.tostring(close), xloc.bar_index, yloc.abovebar,  color.rgb(137, 0, 130), label.style_label_upper_left, color.white, size.tiny, text.align_center, '')
        if alertDirectionalBuySell
            alert("Close Position", alert.freq_once_per_bar)

    if buyLong
        if showBuySellLevels
            draw_buymarker(limitLevel, TP, SL)

        if alertDirectionalBuySell and not buyLong[1]
            alert("Directional Buy @ " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if buyCross
        if showBuySellLevels
            draw_buymarker(limitLevel, TP, SL)
        if alertCrossBuySell and not buyCross[1]
            alert("Cross Buy @ " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if buyReversalTrigger
        if showBuySellLevels
            draw_buymarker(limitLevel, TP, SL)
        if alertCrossBuySell and not buyReversalTrigger[1]
            alert("Reversal Buy @ " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if sellShort
        if showBuySellLevels
            draw_sellmarker(limitLevel, TP, SL)
        if alertDirectionalBuySell and not buyCross[1]
            alert("Directional Sell @ " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if sellCross
        if showBuySellLevels
            draw_sellmarker(limitLevel, TP, SL)
        if alertCrossBuySell and not sellCross[1]
            alert("Cross Sell @ " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if sellReversalTrigger
        if showBuySellLevels
            draw_sellmarker(limitLevel, TP, SL)
        if alertReversalBuySell and not sellReversalTrigger[1]
            alert("Reversal Sell @ " + str.tostring(limitLevel), alert.freq_once_per_bar)


// ***** PLOT SHAPES *****
plotshape(series=close, title="Directional Long", style=shape.triangleup, location=location.bottom, color= buyLong and validTriggerPeriod  ? color.green : na, size=size.small)
plotshape(series=close, title="Reversal Long", style=shape.flag, location=location.bottom, color= buyReversalTrigger and validTriggerPeriod ? color.green : na, size=size.small)
plotshape(series=close, title="Cross Long", style=shape.labelup, location=location.bottom, color= buyCross and validTriggerPeriod  ? color.green : na, size=size.small)
plotshape(series=close, title="Directional Short", style=shape.triangledown, location=location.top, color= sellShort and validTriggerPeriod  ? color.red : na, size=size.small)
plotshape(series=close, title="Reversal Short", style=shape.flag, location=location.top, color= sellReversalTrigger and validTriggerPeriod ? color.red : na, size=size.small)
plotshape(series=close, title="Cross Short", style=shape.labeldown, location=location.top, color= sellCross and validTriggerPeriod  ? color.red : na, size=size.small)

// ********** ALERTS **********
if (anyPivotSym1Bounce or anyPivotSym2Bounce) and alertPivotsBounce
    alert("Bounce off pivot level at" + str.tostring(bounceLevel), alert.freq_once_per_bar_close)

if (anyBuySym1Bounce or anyBuySym2Bounce) and alertBuyBounce
    alert("Bounce off buy level at" + str.tostring(bounceLevel), alert.freq_once_per_bar_close)

if (anySellSym1Bounce or anySellSym2Bounce) and alertSellBounce
    alert("Bounce off sell level at" + str.tostring(bounceLevel), alert.freq_once_per_bar_close)

if (anyIntraSym1Bounce or anyIntraSym2Bounce) and alertIntraBounce
    alert("Bounce off intra level at"  + str.tostring(bounceLevel), alert.freq_once_per_bar_close)

if alertATRArrow
    if buyATRSignal and not buyATRSignal[1]
        alert('ATR Trigger Long on: ' + str.tostring(syminfo.ticker), alert.freq_once_per_bar_close)
    else if sellATRSignal and not sellATRSignal[1]
        alert('ATR Trigger Short on: ' + str.tostring(syminfo.ticker), alert.freq_once_per_bar_close)