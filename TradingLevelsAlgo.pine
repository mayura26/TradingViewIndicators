//@version=5
// Author is not responsible for your trading using this script.
// Data provided in this script is not financial advice.
// Based on my own ideas and ideas from Saty ATR Levels, posty's pivots, @midtownsk8rguy and other scripts.

// TODO: Create flashing sign for big trend.

// TODO: Rework the triggers and alerts to be in line with volume analysis

// TODO: Add predictive volume indicator for cross

// TODO: Modifify Code so it checks timezone/confluences

// TODO: create min number of confluences for a cross auto buy

// TODO: Update buy/sell text to show levels from entry to close. Add buy/sell levels to be tooltip

// TODO: Add trade dashboard showing status of trades

// TODO: Reorganise inputs

// TODO: Review all tooltips

// FEATURE: Supertrend

// FEATURE: DRSI and cross of UVXY

// FEATURE: Orderflow oscilator

// FEATURE: Lorezian classsifcations

// ********** BASE SETUP **********
indicator("Trading Levels Algo", max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, overlay=true)

// ********** INPUTS **********

// Define input for ticker
sym1 = input.symbol("CME_MINI:MNQ1!", "Ticker 1 [Trading Ticker]", group="Tickers", tooltip = "This is the ticker which will be used for buy/sell indications and trading")
sym2 = input.symbol("AMEX:SPY", "Ticker 2", group="Tickers", tooltip = "This is a secondary ticker which levels can be setup for and plotted/alerted. The purpose of this ticker is to provide confluences on a secondary ticker.")

// Define input for pivots
sym1Pivots = input("", title="Pivot", group="Ticker 1 Levels (comma delimited)", inline="line1")
sym1BuyLevels = input("", title="  |  Buy", group="Ticker 1 Levels (comma delimited)", inline="line1")
sym1SellLevels = input("", title="Sell ", group="Ticker 1 Levels (comma delimited)", inline="line2")
sym1IntraDayLevels  = input("", title="  |  Intraday", group="Ticker 1 Levels (comma delimited)", inline="line2")
sym2Pivots = input("", title="Pivot", group="Ticker 2 Levels (comma delimited)", inline="line1")
sym2BuyLevels = input("", title="  |  Buy", group="Ticker 2 Levels (comma delimited)", inline="line1")
sym2SellLevels = input("", title="Sell ", group="Ticker 2 Levels (comma delimited)", inline="line2")
sym2IntraDayLevels  = input("", title="  |  Intraday", group="Ticker 2 Levels (comma delimited)", inline="line2")

// Define input for line settings
pivotsColor = input.color(color.purple, title="Pivot Color", group="Level Settings", inline = "pivots")
pivotsLabel = input("Pivot", title="Pivots Label", group="Level Settings", inline = "pivots")
pivotsWidth = input(2, title="    └ Pivots Width", group="Level Settings", inline = "pwidth")

buyColor = input.color(color.rgb(9, 122, 5), title="Buy Level Color", group="Level Settings", inline = "buy")
buyLabel = input("Buy", title="Buy Level Label", group="Level Settings", inline = "buy")
buyWidth = input(2, title="    └ Buy Level Width", group="Level Settings", inline = "bwidth")

sellColor = input.color(color.rgb(161, 33, 33), title="Sell Level  Color", group="Level Settings", inline = "sell")
sellLabel = input("Sell", title="Sell Level Label", group="Level Settings", inline = "sell")
sellWidth = input(2, title="    └ Sell Level Width", group="Level Settings", inline = "swidth")

intraColor = input.color(color.orange, title="Intraday Color", group="Level Settings", inline = "intra")
intraLabel = input("Intra", title="Intraday Label", group="Level Settings", inline = "intra")
intraWidth = input(2, title="    └ Intraday Width", group="Level Settings", inline = "iwidth")

preCalcColor = input.color(color.rgb(0, 255, 255), title="Calculated Color", group="Level Settings", inline = "preCalc")
preCalcLabel = input("Calc", title="Calculated Label", group="Level Settings", inline = "preCalc")
preCalcWidth = input(2, title="    └ Calculated Width", group="Level Settings", inline = "pcwidth")

// Calculated Levels
showDailyLevels = input(true, title="Show Daily Levels", group="Calculated Levels", tooltip = "This will show the daily levels on the chart. These are calculated from the previous day's high, low, and close.")
showWeeklyLevels = input(true, title="Show Weekly Levels", group="Calculated Levels", tooltip = "This will show the weekly levels on the chart. These are calculated from the previous week's high, low, and close.")
showYesterdayLevels = input(true, title="Show Yesterday Levels", group="Calculated Levels", tooltip = "This will show the yesterday levels on the chart. These are calculated from the previous day's high, low, and close.")
showATRLevels = input(true, title="Show ATR Levels", group="Calculated Levels", tooltip = "This will show the ATR levels on the chart. These are calculated from the ATR and show the bearish and bullish levels, as well ATR(-1/-0.618) and ATR(1/0.618).")
showCamLevels = input(true, title="Show Camarilla Levels", group="Calculated Levels", tooltip = "This will show the Camarilla levels on the chart. This is the S4, S6, R4, R6 levels")
showORBLevels = input(true, title="Show ORB Levels", group="Calculated Levels", tooltip = "This will show the Opening Range Breakout levels on the chart. This is the high and low of the first (15/30/60) minutes of the trading day.")
timeBeforeLevelLive = input(15, title="Time Before Level Live [min]", group="Calculated Levels", tooltip = "Time before level becomes live and is used in triggers. This is to prevent the level from being used too early while still being set (e.g. high of day).")

labelOffset = input(-1, title="Label Offset", group="General", tooltip = "This is the offset of the labels for the lines. Caution can sometimes end up in the wrong place and will move when this is adjusted. Seems to be a function of TradingView repainting.")
clashLineTransp = input(50,title="Clashing Line Transparency", group="General", tooltip = "The transparency  of lines when they are clashing")
levelBounceBuffer = input.float(15.0, title="Level Bounce Buffer [H-L] (%)", group="General", minval=0, maxval=100, tooltip = "This is the offset for the level bounce. This is a percentage of the high/low range of the bar. If the close/open is within this buffer of the level, it will be considered a bounce.")
buySellBuffer = input.float(10, title="Buy/Sell Offset [ticks]", group="General",minval=0, tooltip = "This is the offset for the buy/sell levels. This is in ticks and will be used to determine the optimal level for the buy/sell.")
reversalOffset = input.float(5, title="Reversal Offset [ticks]", group="General",minval=0, tooltip = "This is the offset for the reversal levels. This is in ticks and will be used to determine the optimal level for the reversal buy/sell.")
levelClashOffset = input.float(60, title="Level Clash Buffer [ticks]", group="General",minval=0, tooltip = "This the level clash offset. This is in ticks and will be used to determine if levels are too close to each other. If levels are within this buffer, they will not be drawn.")
lowerTF = input.int(3, title="MA Timeframe [min]", group="General",minval=0, maxval=10, tooltip = "This is the timeframe for the MA. This is in minutes and will be used to calculate the MA.") 
trendTF = input.int(10, title="Trend Timeframe [min]", group="General",minval=0, maxval=10, tooltip = "This is the timeframe for the trend on the dashboard.")
enableCentralChopZone = input(true, title="Enable Central Chop Zone", group="General", tooltip = "Enable the central chop zone. This is when the last 10m 5 candles, at least 3 of them are flipping and range less than 30. Then that range is consider a chop range. Trades won't be taken in this range.")
chopZoneMaxRange = input(40, title="Chop Zone Max Range", group="General", tooltip = "This is the max range for the chop zone. This is in points and will be used to determine if the range is a chop zone.")
resetChopZoneTime = input(120,title="Chop Zone Time To Show Zone [min]", group="General", tooltip = "This is the amount of time in minutes that the chopzone will be shown after being identified.")

crossLookbackTime = input.int(12, title="Crossover Lookback Timeframe [min]", group="General",minval=3, maxval=30, tooltip="Lookback time after a crossover/ATR trigger to check for bounces off levels.")
bounceLookbackTime = input.int(12, title="Bounce Lookback Timeframe [min]", group="General",minval=3, maxval=30, tooltip="Lookback time to look for a bounce off a level to trigger a buy/sell.")
crossATRLookbackTime = input.int(9, title="Crossover/ATR Lookback Timeframe [min]", group="General",minval=3, maxval=30, tooltip="Lookback time after a crossover/ATR trigger to check for a crossover/ATR.")
showAllConditions = input(false, title="Show Conditions for Entry", group = "General", tooltip="This will show all the conditions being triggered. Mostly useful for debugging.")
showBuySellLevels = input(false, title="Show Buy/Sell Text", group = "General", tooltip="This will show the buy/sell levels on the chart. Ideal if you want to see the actual price to enter the trade.")
showBuySellMarkers = input(false, title="Show Buy/Sell Marker | ", group = "General", inline = "marker", tooltip="This will show the buy/sell markers on the chart with the TP/SL levels. Useful for debugging and reviewing trades. Recommended to keep this off for live trading.")
tpLevel = input(240, title="Take Profit [ticks]", group = "General", inline = "marker")
slLevel = input(60, title="        └ Stop Loss [ticks]", group = "General", inline = "marker2")

showPivotsBounce = input(true, title=" Show Pivot Level Bounce Symbol   |   ", group="Level Bounce (Pivot)", inline="alert")
alertPivotsBounce = input(true, title="Alert on Pivot Bounce", group="Level Bounce (Pivot)",inline="alert")
includeTrigPivots = input(true, title="Trigger Buy/Sell   |   ", group="Level Bounce (Pivot)", inline="pivot")
includeRevPivots = input(true, title="Trigger Reversal", group="Level Bounce (Pivot)", inline="pivot")

showBuyBounce = input(true, title=" Show Buy Level Bounce Symbol   |   ", group="Level Bounce (Buy)", inline="alert")
alertBuyBounce = input(true, title="Alert on Buy Bounce", group="Level Bounce (Buy)",inline="alert")
includeTrigBuy = input(true, title="Trigger Buy/Sell   |   ", group="Level Bounce (Buy)", inline="Buy")
includeRevBuy = input(true, title="Trigger Reversal", group="Level Bounce (Buy)", inline="Buy")

showSellBounce = input(true, title=" Show Sell Level Bounce Symbol   |   ", group="Level Bounce (Sell)", inline="alert")
alertSellBounce = input(true, title="Alert on Sell Bounce", group="Level Bounce (Sell)",inline="alert")
includeTrigSell = input(true, title="Trigger Buy/Sell   |   ", group="Level Bounce (Sell)", inline="Sell")
includeRevSell = input(true, title="Trigger Reversal", group="Level Bounce (Sell)", inline="Sell")

showIntraBounce = input(true, title=" Show Intra Level Bounce Symbol   |   ", group="Level Bounce (Intra)", inline="alert")
alertIntraBounce = input(true, title="Alert on Intra Bounce", group="Level Bounce (Intra)",inline="alert")
includeTrigIntra = input(true, title="Trigger Buy/Sell   |   ", group="Level Bounce (Intra)", inline="Intra")
includeRevIntra = input(true, title="Trigger Reversal", group="Level Bounce (Intra)", inline="Intra")

showPreCalcBounce = input(false, title=" Show Calc Level Bounce Symbol   |   ", group="Level Bounce (PreCalc)", inline="alert")
alertPreCalcBounce = input(true, title="Alert on Calc Bounce", group="Level Bounce (PreCalc)",inline="alert")
includeTrigPreCalc = input(false, title="Trigger Buy/Sell   |   ", group="Level Bounce (PreCalc)", inline="PreCalc")
includeRevPreCalc = input(true, title="Trigger Reversal", group="Level Bounce (PreCalc)", inline="PreCalc")

// ATR
showATRArrow = input(true, title="Show ATR Arrow", group="ATR")
atrArrowTransparency = input.int(20, title="    └ ATR Arrow Transparency", group="ATR", minval=0, maxval=100)
showATRDots = input(true, title="Show ATR Dots", group="ATR", inline="main")
atrDotTransparency = input.int(80, title="    └ ATR Dot Transparency", group="ATR", minval=0, maxval=100)
buyATRColor = input(color.rgb(20, 161, 44), title="Buy ATR Color", group="ATR", inline="color")
sellATRColor = input(color.rgb(133, 0, 55), title="   |   Sell ATR Color", group="ATR", inline="color")

// Volume Analysis
showVolIndicator = input(true, title="Show Volume Indicator", group="Volume Analysis", tooltip="Show the volume indicator for each bar. This is analysing the buy and sell volume and attempting to identify the trend directions. The triangle up or down indicates the cross of the volume, which is the start of the new trend. The circle indicates onesided volume. The cross indicates irregular volume (higher than the last period averaged). A square is the default state.")
showVolDashboard = input(true, title="Show Volume Dashboard", group="Volume Analysis")
showVolTrade = input(true, title="Show Volume Trades", group="Volume Analysis", tooltip="Show the volume trades on the chart. This will show the buy/sell symbol.")
showVolTradeClose = input(true, title="Show Volume Trades Close", group="Volume Analysis", tooltip="Show a symbol when to close a volume trade.")
volTopLimit = input(85, title="Volume Top Limit [%]", group="Volume Analysis", tooltip="This is the top limit used to decide is there is a significant volume imbalance.")
volUpperLimit = input(75, title="Volume Upper Limit [%]", group="Volume Analysis", tooltip="This is the top limit used to decide is there is a significant volume imbalance.")
volPumpGainLimit = input(5, title="Volume Pump Gain Limit [%]", group="Volume Analysis", tooltip="This is the gain limit to decide if volume is ramping. It is a percentage change of the buy or sell volume.")
volIrregLimit = input(150, title="Irregular Volume Limit [%]", group="Volume Analysis", tooltip="This is the limit for irregular volume. This is a percentage change of  total volume from the last averaged period.")
aveVolPeriod = input(14, title="Average Volume Period", group="Volume Analysis", tooltip="This is the period to average the volume for the volume analysis.")
volSmooth = input(5, title="Volume Smooth Period", group="Volume Analysis", tooltip="This is the smooth period for the volume. This will smooth the volume to reduce noise. Keep this low for faster response but less smooth trends.")
volBarsToMissTrade = input(4, title="Non-directional Bars to Close", group="Volume Analysis", tooltip="Number of bars where the volume profile is not in the direction of the trade to close the trade. The higher this is, the smoother your trade buy/sells will be, but you risk letting a good trade go bad. This does not effect reversals which will close the trade.")
volCloseOnReversalOnly = input(false, title="Close on Reversal Only", group="Volume Analysis", tooltip="Close the volume trade only on a reversal. This will stop trade only on the reverse direction triggering. Don't recommend this on any volatile instruments.")
volBarsToMissNegDelta = input(1, title="Non-directional Bars to Close (Negative Delta Trade)", group="Volume Analysis", tooltip="Number of bars used when the trade is a negative delta volume trade (so buy negative volume, sell negative volume). This should be lower as these trades are generally less likely to breakout and more likely to reverse.")
volBarsToMissPosDelta = input(3, title="Non-directional Bars to Close (Positive Delta Trade)", group="Volume Analysis", tooltip="Number of bars used when the trade is a positive delta volume trade (so buy positive volume, sell negative volume). This can be a bit higher as these trades are more stable but can be reduced to increase profits vs risk of reversal.")
resetBarsMissedOnLong = input(false, title="Reset Bars Missed on Long", group="Volume Analysis", tooltip="Reset the bars missed when the trade is a long trade. Have this on when long trades are more likely to be profitable and not reverse.")
resetBarsMissedOnShort = input(true, title="Reset Bars Missed on Short", group="Volume Analysis", tooltip="Reset the bars missed when the trade is a short trade. Have this on when short trades are more likely to be profitable and not reverse.")
deltaVolPosCutoff = input(2.5, title="Positive Delta Volume Cutoff [%]", group="Volume Analysis", tooltip="Positive cutoff in delta volume for candle highlighting.")
deltaVolNegCutoff = input(2.5, title="Negative Delta Volume Cutoff [%]", group="Volume Analysis", tooltip="Negative cutoff in delta volume for candle highlighting.")
enableDeltaVolShadow = input(true, title="Enable Delta Volume Shadow", group="Volume Analysis", tooltip="Enable the delta volume shadow. This will show the delta volume as a shadow on the candle.")
deltaVolTrendVolColor = input(color.rgb(33,181,212,85), title="Trend Volume Color", group="Volume Analysis", tooltip="Color for the delta trend volume. (Both buy and sell volume moving upwards)")
deltaVolBuyVolColor = input(color.rgb(32,192,93,85), title="Buy Volume Color", group="Volume Analysis", tooltip="Color for the buy volume. (Only buy volume positive)")
deltaVolSellVolColor = input(color.rgb(255,32,93,85), title="Sell Volume Color", group="Volume Analysis", tooltip="Color for the sell volume. (Only sell volume positive)")
deltaVolNegVolColor = input(color.rgb(255,222,32,85), title="Negative Volume Color", group="Volume Analysis", tooltip="Color for the negative volume. (Both buy and sell volume moving downwards)")

// Define EMA/SMA settings
periodFastMA = input(8, title="Fast MA Period", group="Moving Averages", inline="fast")
colorFastMA = input.color(color.new(color.fuchsia,80), title="Fast MA Color", group="Moving Averages", inline="fast")
typeFastMA = input.string("EMA", title="    └ Fast MA Type", options=["EMA", "IMD"], group="Moving Averages", inline="tfast", tooltip="This is the type of MA to use for the fast MA. IMD is the Improved McGinley Dynamic.")

periodSlowMA = input(13, title="Slow MA Period", group="Moving Averages", inline="slow")
colorSlowMA = input.color(color.new(color.green,80), title="Slow MA Color", group="Moving Averages", inline="slow")
typeSlowMA = input.string("EMA", title="    └ Slow MA Type", options=["EMA", "IMD"], group="Moving Averages", inline="tslow", tooltip="This is the type of MA to use for the slow MA. IMD is the Improved McGinley Dynamic.")

periodStableMA = input(21, title="Stable MA Period", group="Moving Averages", inline="Stable")
colorStableMA = input.color(color.new(color.red,80), title="Stable MA Color", group="Moving Averages", inline="Stable")
typeStableMA = input.string("EMA", title="    └ Stable MA Type", options=["EMA", "IMD"], group="Moving Averages", inline="tStable", tooltip="This is the type of MA to use for the stable MA. IMD is the Improved McGinley Dynamic.")

showVWAP = input(true, title="Show VWAP  |  ", group="Moving Averages", inline="VWAP")
colorVWAP = input(color.new(color.yellow,20), title="VWAP Color", group="Moving Averages", inline="VWAP")

showConfirmMA = input(true, title="Show Confirm MA   |   ", group="Moving Averages", inline="confirm")
confirmMASmoothPeriod = input(1, title="Confirm MA Smooth Period", group="Moving Averages", inline="confirm", tooltip="This is the smooth period for the confirm MA. The confirm MA is already smoothed, but this will add additional smoothing if required at the cost of slower response.")

alertDirectionalBuySell = input(true, title="Buy/Sell", group="Alerts", inline="main")
alertReversalBuySell = input(true, title="Buy/Sell (Reversal)", group="Alerts", inline="main")
alertCrossBuySell = input(true, title="Buy/Sell (Cross)", group="Alerts", inline="main")
alertATRArrow = input(false, title="ATR Arrow", group="Alerts", inline="main2")
alertVolumeChange = input(false, title="Volume Direction Change", group="Alerts", inline="main2")
alertVolTrade = input(true, title="Alert on Volume Trade", group="Alerts", tooltip="Alert when a volume trade is triggered.", inline="main3")
alertVolTradeClose = input(true, title="Alert on Volume Trade Close", group="Alerts", tooltip="Alert when a volume trade is triggered.", inline="main3")

show_table      = input.bool(true,"Show Dashboard", group="Dashboard", inline="Table")
tableLocation   = input.string(defval='Bottom right', options=['Top left', 'Top center', 'Top right', 'Bottom left', 'Bottom center', 'Bottom right'], title='| Location', group="Dashboard", inline="Table")
tablePosition   = tableLocation == 'Top left' ? position.top_left : tableLocation == 'Top center' ? position.top_center : tableLocation == 'Top right' ? position.top_right : tableLocation == 'Bottom left' ? position.bottom_left : tableLocation == 'Bottom center' ? position.bottom_center : position.bottom_right
table_font_size       = input.string('Normal', "    └ Font Size", options = ['Auto', 'Tiny', 'Small', 'Normal', 'Large'], group="Dashboard", inline = 'line2')
table_bgcolor       = input.color(color.gray, title="Background Color", group="Dashboard", inline="line3")
table_fontcolor       = input.color(color.white, title="  |  Font Color", group="Dashboard", inline="line3")

timePeriod1 = input.session("1000-1615", title="Trade Period 1", group="Trading Time (NY Time)")
timePeriod1VolTriggerEnabled = input(true, title="Volume Trades Enabled", group="Trading Time (NY Time)")
timePeriod1CrossTriggerEnabled = input(true, title="Cross Trades Enabled  |  ", group="Trading Time (NY Time)", inline="tp1Cross")
timePeriod1CrossMinConfluence = input(2, title="Min Confluences", group="Trading Time (NY Time)", inline="tp1Cross")
timePeriod1DirectionalTriggerEnabled = input(true, title="Directional Trades Enabled  |  ", group="Trading Time (NY Time)", inline="tp1Dir")
timePeriod1DirectionalMinConfluence = input(2, title="Min Confluences", group="Trading Time (NY Time)", inline="tp1Dir")
timePeriod1ReversalTriggerEnabled = input(true, title="Directional Trades Enabled  |  ", group="Trading Time (NY Time)", inline="tp1Rev")
timePeriod1ReversalMinConfluence = input(2, title="Min Confluences", group="Trading Time (NY Time)", inline="tp1Rev")
timePeriod2 = input.session("0600-1000", title="Trade Period 2", group="Trading Time (NY Time)")
timePeriod2VolTriggerEnabled = input(true, title="Volume Trades Enabled", group="Trading Time (NY Time)")
timePeriod2CrossTriggerEnabled = input(true, title="Cross Trades Enabled  |  ", group="Trading Time (NY Time)", inline="tp2Cross")
timePeriod2CrossMinConfluence = input(2, title="Min Confluences", group="Trading Time (NY Time)", inline="tp2Cross")
timePeriod2DirectionalTriggerEnabled = input(true, title="Directional Trades Enabled  |  ", group="Trading Time (NY Time)", inline="tp2Dir")
timePeriod2DirectionalMinConfluence = input(2, title="Min Confluences", group="Trading Time (NY Time)", inline="tp2Dir")
timePeriod2ReversalTriggerEnabled = input(true, title="Directional Trades Enabled  |  ", group="Trading Time (NY Time)", inline="tp2Rev")
timePeriod2ReversalMinConfluence = input(2, title="Min Confluences", group="Trading Time (NY Time)", inline="tp2Rev")
timePeriod3 = input.session("1700-1715", title="Trade Period 3", group="Trading Time (NY Time)")
timePeriod3VolTriggerEnabled = input(true, title="Volume Trades Enabled", group="Trading Time (NY Time)")
timePeriod3CrossTriggerEnabled = input(true, title="Cross Trades Enabled  |  ", group="Trading Time (NY Time)", inline="tp3Cross")
timePeriod3CrossMinConfluence = input(2, title="Min Confluences", group="Trading Time (NY Time)", inline="tp3Cross")
timePeriod3DirectionalTriggerEnabled = input(true, title="Directional Trades Enabled  |  ", group="Trading Time (NY Time)", inline="tp3Dir")
timePeriod3DirectionalMinConfluence = input(2, title="Min Confluences", group="Trading Time (NY Time)", inline="tp3Dir")
timePeriod3ReversalTriggerEnabled = input(true, title="Directional Trades Enabled  |  ", group="Trading Time (NY Time)", inline="tp3Rev")
timePeriod3ReversalMinConfluence = input(2, title="Min Confluences", group="Trading Time (NY Time)", inline="tp3Rev")
orbSession = input.session("0930-1000", title="ORB Calculation Time", group="Trading Time (NY Time)", tooltip="This is the time for the Opening Range Breakout calculation.Reccomended to set this to the first 15-60 minutes of the trading day.")

// ********** GLOBAL VARIABLES *********
// System variables
var displayTable = table.new(tablePosition, 2, 6, border_width=1, bgcolor = table_bgcolor)
var float bounceLevel = na
var int systemState = 0
var bool lastCrossDir = na
var bool lastVolTradeDir = na

// Constants
var int startOfDayIndex = na
var int startOfWeekIndex = na

// Check if this is the first bar of the new day
if (dayofmonth != dayofmonth[1] or month != month[1] or year != year[1])
    startOfDayIndex := bar_index

if (weekofyear != weekofyear[1])
    startOfWeekIndex := bar_index

// Arrays
var line [] lineArray = array.new_line()
var label [] labelArray = array.new_label()
var float [] liveLevels = array.new_float() 
var float [] calcLevels = array.new_float() 
for line in lineArray
    line.delete(line)
for label in labelArray
    label.delete(label)
array.clear(lineArray)    
array.clear(labelArray)
array.clear(liveLevels)
array.clear(calcLevels)

// ********** FUNCTIONS **********
draw_line(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    dline = line.new(x1=_x1, y1=_y1, x2=_x2, y2=_y2, xloc=_xloc, extend=_extend, color=_color, style=_style, width=_width)
    array.push(lineArray,dline)

draw_label(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    dlabel = label.new(x=_x, y=_y, text=_text, xloc=_xloc, yloc=_yloc, color=_color, style=_style, textcolor=_textcolor, size=_size, textalign=_textalign, tooltip=_tooltip)

draw_buymarker(limitLevel,TP,SL) =>
    draw_label(bar_index, limitLevel, "Buy @ " + str.tostring(limitLevel), xloc.bar_index, yloc.abovebar,  color.teal, label.style_text_outline, color.white, size.small, text.align_center, '')
    draw_label(bar_index, limitLevel, "", xloc.bar_index, yloc.price,  color.teal, label.style_cross, color.white, size.tiny, text.align_center, '')
    if showBuySellMarkers
        draw_label(bar_index, limitLevel + TP, "", xloc.bar_index, yloc.price,  color.rgb(1, 221, 199), label.style_triangledown, color.white, size.tiny, text.align_center, '')
        draw_label(bar_index, limitLevel - SL, "", xloc.bar_index, yloc.price,  color.rgb(0, 56, 50), label.style_triangleup, color.white, size.tiny, text.align_center, '')
        line.new(bar_index,limitLevel + TP, bar_index, limitLevel - SL,xloc.bar_index,extend.none,color.teal,line.style_dotted,2)

draw_sellmarker(limitLevel,TP,SL) =>
    draw_label(bar_index, limitLevel, "Sell @ " + str.tostring(limitLevel), xloc.bar_index, yloc.abovebar,  color.rgb(137, 0, 0), label.style_text_outline, color.white, size.small, text.align_center, '')
    draw_label(bar_index, limitLevel, "", xloc.bar_index, yloc.price,  color.rgb(137, 0, 0), label.style_cross, color.white, size.tiny, text.align_center, '')
    if showBuySellMarkers
        draw_label(bar_index, limitLevel - TP, "", xloc.bar_index, yloc.price,  color.rgb(221, 1, 1), label.style_triangleup, color.white, size.tiny, text.align_center, '')
        draw_label(bar_index, limitLevel + SL, "", xloc.bar_index, yloc.price,  color.rgb(56, 0, 0), label.style_triangledown, color.white, size.tiny, text.align_center, '')
        line.new(bar_index,limitLevel + TP, bar_index, limitLevel - SL,xloc.bar_index,extend.none,color.rgb(137, 0, 0),line.style_dotted,2)

check_bounce_high(level) =>
    highBounce = high >= level - (high - low) * (levelBounceBuffer/100) and close < level - (high - low) * (levelBounceBuffer/100) and (open <= level + (high - low) * (levelBounceBuffer/100)) and barstate.isconfirmed

check_bounce_low(level) =>
    lowBounce = low <= level + - (high - low) * (levelBounceBuffer/100) and close > level + (high - low) * (levelBounceBuffer/100) and (open >= level - (high - low) * (levelBounceBuffer/100)) and barstate.isconfirmed

check_levels_low(levels, bounceType, symbolEnabled) =>    
    plotLevels = str.split(levels, ",")
    anyBounce = false
    limitLevel = 0.0
    for level in plotLevels
        if check_bounce_low(str.tonumber(level))
            anyBounce := true
            limitLevel := str.tonumber(level)
            if symbolEnabled
                labelText = bounceType
                if showAllConditions
                    labelText := bounceType + "(" + str.tostring(math.round_to_mintick((high - low) * (levelBounceBuffer/100))) + ")"
                draw_label(bar_index, str.tonumber(level), labelText, xloc.bar_index, yloc.belowbar,  color.green, label.style_label_up, color.white, size.small, text.align_center, '')
    [anyBounce, limitLevel]

check_levels_high(levels, bounceType, symbolEnabled) =>    
    plotLevels = str.split(levels, ",")
    anyBounce = false
    limitLevel = 0.0
    for level in plotLevels
        if check_bounce_high(str.tonumber(level))
            anyBounce := true
            limitLevel := str.tonumber(level)
            if symbolEnabled
                labelText = bounceType
                if showAllConditions
                    labelText := bounceType + "(" + str.tostring(math.round_to_mintick((high - low) * (levelBounceBuffer/100))) + ")"
                draw_label(bar_index, str.tonumber(level), labelText, xloc.bar_index, yloc.abovebar,  color.red, label.style_label_down, color.white, size.small, text.align_center, '')
    [anyBounce, limitLevel]

check_calclevels_low(levels, bounceType, symbolEnabled) =>    
    anyBounce = false
    limitLevel = 0.0
    for level in levels
        if check_bounce_low(level)
            anyBounce := true
            limitLevel := level
            if symbolEnabled
                labelText = bounceType
                if showAllConditions
                    labelText := bounceType + "(" + str.tostring(math.round_to_mintick((high - low) * (levelBounceBuffer/100))) + ")"
                draw_label(bar_index, level, labelText, xloc.bar_index, yloc.belowbar,  color.green, label.style_label_up, color.white, size.small, text.align_center, '')
    [anyBounce, limitLevel]

check_calclevels_high(levels, bounceType, symbolEnabled) =>    
    anyBounce = false
    limitLevel = 0.0
    for level in levels
        if check_bounce_high(level)
            anyBounce := true
            limitLevel := level
            if symbolEnabled
                labelText = bounceType
                if showAllConditions
                    labelText := bounceType + "(" + str.tostring(math.round_to_mintick((high - low) * (levelBounceBuffer/100))) + ")"
                draw_label(bar_index, level, labelText, xloc.bar_index, yloc.abovebar,  color.red, label.style_label_down, color.white, size.small, text.align_center, '')
    [anyBounce, limitLevel]

draw_levels(levels, color, width, label, labeloffset) =>
    plotLevels = str.split(levels, ",")
    for level in plotLevels
        array.push(liveLevels, str.tonumber(level))
        if barstate.islast
            draw_line(bar_index, str.tonumber(level), bar_index + labeloffset + 15, str.tonumber(level),  xloc.bar_index, extend.left, color, line.style_solid, width)
            plot_label = label.new(bar_index + labeloffset + 10, str.tonumber(level))
            label.set_text(plot_label, label)
            label.set_style(plot_label, label.style_none)
            label.set_textcolor(plot_label, color)
            label.set_textalign(plot_label, text.align_right)
            array.push(labelArray, plot_label)

draw_levels_calculated(level, color, width, label, labeloffset, startBar) =>
    offset = levelClashOffset * syminfo.mintick
    shouldDraw = true
    for levelInArray in liveLevels
        if level != levelInArray and level >= levelInArray - offset and level <= levelInArray + offset
            // Level is within offset, do not draw
            shouldDraw := false
            break
    if shouldDraw
        array.push(liveLevels, level)
        array.push(calcLevels, level)
        draw_line(startBar, level, bar_index + labeloffset + 15, level,  xloc.bar_index, extend.none, color, line.style_solid, width)

    if not shouldDraw
        draw_line(startBar, level, bar_index + labeloffset + 15, level,  xloc.bar_index, extend.none, color.new(color, clashLineTransp), line.style_dotted, width)

    if barstate.islast
        plot_label = label.new(bar_index + labeloffset + 10, level)
        label.set_text(plot_label, label)
        label.set_style(plot_label, label.style_none)
        label.set_textcolor(plot_label, shouldDraw ? color : color.new(color, clashLineTransp))
        label.set_textalign(plot_label, text.align_right)
        array.push(labelArray, plot_label)

draw_levels_showonly(level, color, width, label, labeloffset, startBar) =>
    offset = levelClashOffset * syminfo.mintick
    draw_line(startBar, level, bar_index + labeloffset + 15, level,  xloc.bar_index, extend.none, color.new(color, clashLineTransp), line.style_dotted, width)

    if barstate.islast
        plot_label = label.new(bar_index + labeloffset + 10, level)
        label.set_text(plot_label, label)
        label.set_style(plot_label, label.style_none)
        label.set_textcolor(plot_label, color.new(color, clashLineTransp))
        label.set_textalign(plot_label, text.align_right)
        array.push(labelArray, plot_label)
    
f_fillCell(_row, _column,series string _cellText, _tooltip) =>
    switch table_font_size
        "Auto" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.auto, tooltip = _tooltip)
        "Tiny" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.tiny, tooltip = _tooltip)
        "Small" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.small, tooltip = _tooltip)
        "Normal" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.normal, tooltip = _tooltip)
        "Large" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color.new(chart.bg_color,50), text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.large, tooltip = _tooltip)

f_fillCellColor(_row,_column, color, _tooltip) =>
    table.cell(displayTable,_column,_row, bgcolor=color, tooltip = _tooltip)

f_fillCellColorText(_row, _column, series string _cellText, color, _tooltip) =>
    switch table_font_size
        "Auto" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.auto, tooltip = _tooltip)
        "Tiny" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.tiny, tooltip = _tooltip)
        "Small" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.small, tooltip = _tooltip)
        "Normal" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.normal, tooltip = _tooltip)
        "Large" => table.cell(displayTable, _column, _row, _cellText, bgcolor=color, text_color=table_fontcolor, text_halign = text.align_left, text_valign = text.align_center, text_size = size.large, tooltip = _tooltip)

extractSymbolName(simple string sym) =>
    pos = str.pos(sym, ":")  // Get position of ":" character
    tkr= str.substring(sym, pos+1)

// Function to convert timeframe to minutes
getTimeframeInMinutes() =>
    // Initialize variable for minutes
    var float minutes = na
    // Check if timeframe is in minutes, hours, or days and convert accordingly
    if str.contains(timeframe.period, "D")
        minutes := str.tonumber(str.replace(timeframe.period, "D", "")) * 1440
    else if str.contains(timeframe.period, "H")
        minutes := str.tonumber(str.replace(timeframe.period, "H", "")) * 60
    else if str.contains(timeframe.period, "M")
        minutes := str.tonumber(str.replace(timeframe.period, "M", ""))
    else
        // Assuming direct minute timeframes like "15", "5", etc.
        minutes := str.tonumber(timeframe.period)
    // Return calculated minutes
    minutes

// Function to calculate the limit level
getLimitLevel(priceTarget, close, buyDir) =>
    limitLevel = buyDir ? math.min(priceTarget, close) : math.max(priceTarget, close)
    limitLevel := math.round_to_mintick(limitLevel)

imd(Series, fPeriod) => // "Improved McGinley Dynamic" Function - @midtownsk8rguy
    fK = 0.6
    fExponent = 4.0
    period = math.max(1.0, fPeriod)
    var float result = na 
    priorMD = nz(result[1], Series)
    result := priorMD + (Series - priorMD) / math.min(period, math.max(1.0, fK * period * math.pow(Series / priorMD, fExponent)))

retrieveBounceLevel(newLevel, oldLevel) =>
    returnLevel = oldLevel
    if newLevel > 0
        returnLevel := newLevel
    returnLevel

levelLookBackCheck(level, localLevel, lookBack) =>
    isSame = true
    for i = 1 to lookBack
        if level <= localLevel[i]
            isSame := false
            break
    isSame

// *********** VALID TIMES *************
allowedTimes() =>
    not na(time(timeframe = timeframe.period, session = timePeriod1, timezone = "America/New_York")) or not na(time(timeframe = timeframe.period, session = timePeriod2, timezone = "America/New_York")) or not na(time(timeframe = timeframe.period, session = timePeriod3, timezone = "America/New_York"))

bool validTriggerPeriod = allowedTimes()

// ********** LEVEL RENDERING **********
// Check if symbol matches the selected ticker
if ticker.standard() == sym1
    draw_levels(sym1Pivots, pivotsColor, pivotsWidth, pivotsLabel, labelOffset)
    draw_levels(sym1BuyLevels, buyColor, buyWidth, buyLabel, labelOffset)
    draw_levels(sym1SellLevels, sellColor, sellWidth, sellLabel, labelOffset)
    draw_levels(sym1IntraDayLevels, intraColor, intraWidth, intraLabel, labelOffset)

if ticker.standard() == sym2
    draw_levels(sym2Pivots, pivotsColor, pivotsWidth, pivotsLabel, labelOffset)
    draw_levels(sym2BuyLevels, buyColor, buyWidth, buyLabel, labelOffset)
    draw_levels(sym2SellLevels, sellColor, sellWidth, sellLabel, labelOffset)
    draw_levels(sym2IntraDayLevels, intraColor, intraWidth, intraLabel, labelOffset)

// ********** Calculated Pivot Levels **********
// Get yesterday's levels
[yesterdayClose, yesterdayHigh,yesterdayLow]  = request.security(syminfo.tickerid, "D", [close[1], high[1], low[1]], barmerge.gaps_off, barmerge.lookahead_on)
[lastWeekClose, lastWeekHigh,lastWeekLow]  = request.security(syminfo.tickerid, "W", [close[1], high[1], low[1]], barmerge.gaps_off, barmerge.lookahead_on)
[todayHigh, todayLow] = request.security(syminfo.tickerid, "D", [high, low], barmerge.gaps_off, barmerge.lookahead_on)

// ATR Calculation
atr_length = 14
trigger_percentage = 0.236
atr = request.security(syminfo.tickerid, 'D', ta.atr(atr_length)[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)

range_1 = todayHigh - todayLow
tr_percent_of_atr = range_1 / atr * 100
atrBear = yesterdayClose - trigger_percentage * atr
atrBull = yesterdayClose + trigger_percentage * atr
atrNeg618 = yesterdayClose - atr * 0.618
atr618 = yesterdayClose + atr * 0.618
atrNeg100 = yesterdayClose - atr
atr100 = yesterdayClose + atr

//Calculate camarilla pivots
r = yesterdayHigh - yesterdayLow
R6 = yesterdayHigh / yesterdayLow * yesterdayClose  //Bull target 2
R4 = yesterdayClose + r * (1.1 / 2)  //Bear Last Stand
S4 = yesterdayClose - r * (1.1 / 2)  //Bull Last Stand 
S6 = yesterdayClose - (R6 - yesterdayClose)  //Bear Target 2

// Calculate ORB
orbTime = time(timeframe.period, orbSession, timezone = "America/New_York")
orbSessionActive = not na(orbTime)
orbSessionFirst = orbSessionActive and not orbSessionActive[1]
var float orb_high = na
var float orb_low = na

if orbSessionFirst
    orb_high := high
    orb_low := low
else
    orb_high := orb_high[1]
    orb_low := orb_low[1]
if high > orb_high and orbSessionActive
    orb_high := high
if low < orb_low and orbSessionActive
    orb_low := low

// ********** Draw Calculated Levels **********
// Historical levels
levelLiveLookback = math.floor(timeBeforeLevelLive / getTimeframeInMinutes())

if(showWeeklyLevels)
    draw_levels_calculated(lastWeekHigh, preCalcColor, preCalcWidth, "Previous Week High", labelOffset, startOfWeekIndex)
    draw_levels_calculated(lastWeekLow, preCalcColor, preCalcWidth, "Previous Week Low", labelOffset, startOfWeekIndex)
    draw_levels_calculated(lastWeekClose, preCalcColor, preCalcWidth, "Previous Week Close", labelOffset, startOfWeekIndex)
if (showYesterdayLevels)
    draw_levels_calculated(yesterdayHigh, preCalcColor, preCalcWidth, "Previous High", labelOffset, startOfDayIndex)
    draw_levels_calculated(yesterdayLow, preCalcColor, preCalcWidth, "Previous Low", labelOffset, startOfDayIndex)
    draw_levels_calculated(yesterdayClose, preCalcColor, preCalcWidth, "Previous Close", labelOffset, startOfDayIndex)

// ATR levels
if (showATRLevels)
    draw_levels_calculated(atrBear, preCalcColor, preCalcWidth, "ATR Bearish", labelOffset, startOfDayIndex)
    draw_levels_calculated(atrBull, preCalcColor, preCalcWidth, "ATR Bullish", labelOffset, startOfDayIndex)
    draw_levels_calculated(atrNeg618, preCalcColor, preCalcWidth, "ATR -0.618", labelOffset, startOfDayIndex)
    draw_levels_calculated(atr618, preCalcColor, preCalcWidth, "ATR +0.618", labelOffset, startOfDayIndex)
    draw_levels_calculated(atrNeg100, preCalcColor, preCalcWidth, "ATR -1.0", labelOffset, startOfDayIndex)
    draw_levels_calculated(atr100, preCalcColor, preCalcWidth, "ATR +1.0", labelOffset, startOfDayIndex)

// Camarilla pivots
if (showCamLevels)
    draw_levels_calculated(R6, preCalcColor, preCalcWidth, "Bull Target", labelOffset, startOfDayIndex)
    draw_levels_calculated(R4, preCalcColor, preCalcWidth, "Bear Reversal", labelOffset, startOfDayIndex)
    draw_levels_calculated(S4, preCalcColor, preCalcWidth, "Bull Reversal", labelOffset, startOfDayIndex)
    draw_levels_calculated(S6, preCalcColor, preCalcWidth, "Bear Target", labelOffset, startOfDayIndex)

// Daily levels
if (showDailyLevels)
    if (levelLookBackCheck(todayHigh, high, levelLiveLookback))
        draw_levels_calculated(todayHigh, preCalcColor, preCalcWidth, "Day High", labelOffset, startOfDayIndex)
    else
        draw_levels_showonly(todayHigh, preCalcColor, preCalcWidth, "Day High", labelOffset, startOfDayIndex)
    if (levelLookBackCheck(todayLow, low, levelLiveLookback))
        draw_levels_calculated(todayLow, preCalcColor, preCalcWidth, "Day Low", labelOffset, startOfDayIndex)
    else
        draw_levels_showonly(todayLow, preCalcColor, preCalcWidth, "Day Low", labelOffset, startOfDayIndex)

// ORB levels
if not orbSessionActive and showORBLevels
    if not na(orb_high)
        if (levelLookBackCheck(orb_high, high, levelLiveLookback))
            draw_levels_calculated(orb_high, preCalcColor, preCalcWidth, "ORB High", labelOffset, startOfDayIndex)
        else
            draw_levels_showonly(orb_high, preCalcColor, preCalcWidth, "ORB High", labelOffset, startOfDayIndex)

    if not na(orb_low)
        if (levelLookBackCheck(orb_low, low, levelLiveLookback))
            draw_levels_calculated(orb_low, preCalcColor, preCalcWidth, "ORB Low", labelOffset, startOfDayIndex)
        else
            draw_levels_showonly(orb_low, preCalcColor, preCalcWidth, "ORB Low", labelOffset, startOfDayIndex)

// ********** LEVEL BOUNCE CHECK **********
anyPivotSym1BounceUp = false
anyBuySym1BounceUp = false
anySellSym1BounceUp = false
anyIntraSym1BounceUp = false
anyCalcSym1BounceUp = false

anyPivotSym1BounceDown = false
anyBuySym1BounceDown = false
anySellSym1BounceDown = false
anyIntraSym1BounceDown = false
anyCalcSym1BounceDown = false

anyPivotSym2BounceUp = false
anyBuySym2BounceUp = false
anySellSym2BounceUp = false
anyIntraSym2BounceUp = false
anyCalcSym2BounceUp = false

anyPivotSym2BounceDown = false
anyBuySym2BounceDown = false
anySellSym2BounceDown = false
anyIntraSym2BounceDown = false
anyCalcSym2BounceDown = false

if ticker.standard() == sym1
    [bounceResult1, bounceResultLevel1] = check_levels_low(sym1Pivots, pivotsLabel, showPivotsBounce)
    [bounceResult2, bounceResultLevel2] = check_levels_high(sym1Pivots, pivotsLabel, showPivotsBounce)
    [bounceResult3, bounceResultLevel3] = check_levels_low(sym1BuyLevels, buyLabel, showBuyBounce)
    [bounceResult4, bounceResultLevel4] = check_levels_high(sym1BuyLevels, buyLabel, showBuyBounce)
    [bounceResult5, bounceResultLevel5] = check_levels_low(sym1SellLevels, sellLabel, showSellBounce)
    [bounceResult6, bounceResultLevel6] = check_levels_high(sym1SellLevels, sellLabel, showSellBounce)
    [bounceResult7, bounceResultLevel7] = check_levels_low(sym1IntraDayLevels, intraLabel, showIntraBounce)
    [bounceResult8, bounceResultLevel8] = check_levels_high(sym1IntraDayLevels, intraLabel, showIntraBounce)
    [bounceResult9, bounceResultLevel9] = check_calclevels_low(calcLevels, preCalcLabel, showPreCalcBounce)
    [bounceResult10, bounceResultLevel10] = check_calclevels_high(calcLevels, preCalcLabel, showPreCalcBounce)
    anyPivotSym1BounceUp := bounceResult1
    anyPivotSym1BounceDown := bounceResult2
    anyBuySym1BounceUp := bounceResult3
    anyBuySym1BounceDown := bounceResult4
    anySellSym1BounceUp := bounceResult5
    anySellSym1BounceDown := bounceResult6
    anyIntraSym1BounceUp := bounceResult7
    anyIntraSym1BounceDown := bounceResult8
    anyCalcSym1BounceUp := bounceResult9
    anyCalcSym1BounceDown := bounceResult10
    bounceLevel := retrieveBounceLevel(bounceResultLevel1, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel2, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel3, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel4, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel5, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel6, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel7, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel8, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel9, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel10, bounceLevel)

if ticker.standard() == sym2
    [bounceResult1, bounceResultLevel1] = check_levels_low(sym2Pivots, pivotsLabel, showPivotsBounce)
    [bounceResult2, bounceResultLevel2] = check_levels_high(sym2Pivots, pivotsLabel, showPivotsBounce)
    [bounceResult3, bounceResultLevel3] = check_levels_low(sym2BuyLevels, buyLabel, showBuyBounce)
    [bounceResult4, bounceResultLevel4] = check_levels_high(sym2BuyLevels, buyLabel, showBuyBounce)
    [bounceResult5, bounceResultLevel5] = check_levels_low(sym2SellLevels, sellLabel, showSellBounce)
    [bounceResult6, bounceResultLevel6] = check_levels_high(sym2SellLevels, sellLabel, showSellBounce)
    [bounceResult7, bounceResultLevel7] = check_levels_low(sym2IntraDayLevels, intraLabel, showIntraBounce)
    [bounceResult8, bounceResultLevel8] = check_levels_high(sym2IntraDayLevels, intraLabel, showIntraBounce)
    [bounceResult9, bounceResultLevel9] = check_calclevels_low(calcLevels, preCalcLabel, showPreCalcBounce)
    [bounceResult10, bounceResultLevel10] = check_calclevels_high(calcLevels, preCalcLabel, showPreCalcBounce)
    anyPivotSym2BounceUp := bounceResult1
    anyPivotSym2BounceDown := bounceResult2
    anyBuySym2BounceUp := bounceResult3
    anyBuySym2BounceDown := bounceResult4
    anySellSym2BounceUp := bounceResult5
    anySellSym2BounceDown := bounceResult6
    anyIntraSym2BounceUp := bounceResult7
    anyIntraSym2BounceDown := bounceResult8
    anyCalcSym2BounceUp := bounceResult9
    anyCalcSym2BounceDown := bounceResult10
    bounceLevel := retrieveBounceLevel(bounceResultLevel1, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel2, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel3, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel4, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel5, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel6, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel7, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel8, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel9, bounceLevel)
    bounceLevel := retrieveBounceLevel(bounceResultLevel10, bounceLevel)

anyPivotSym1Bounce = anyPivotSym1BounceUp or anyPivotSym1BounceDown
anyBuySym1Bounce = anyBuySym1BounceUp or anyBuySym1BounceDown
anySellSym1Bounce = anySellSym1BounceUp or anySellSym1BounceDown
anyIntraSym1Bounce = anyIntraSym1BounceUp or anyIntraSym1BounceDown
anyCalcSym1Bounce = anyCalcSym1BounceUp or anyCalcSym1BounceDown

anyPivotSym2Bounce = anyPivotSym2BounceUp or anyPivotSym2BounceDown
anyBuySym2Bounce = anyBuySym2BounceUp or anyBuySym2BounceDown
anySellSym2Bounce = anySellSym2BounceUp or anySellSym2BounceDown
anyIntraSym2Bounce = anyIntraSym2BounceUp or anyIntraSym2BounceDown
anyCalcSym2Bounce = anyCalcSym2BounceUp or anyCalcSym2BounceDown

anySym1BounceUp = (anyPivotSym1BounceUp and includeTrigPivots) or (anyBuySym1BounceUp and includeTrigBuy) or (anySellSym1BounceUp and includeTrigSell) or (anyIntraSym1BounceUp and includeTrigIntra) or (anyCalcSym1BounceUp and includeTrigPreCalc)
anySym1BounceDown = (anyPivotSym1BounceDown and includeTrigPivots) or (anyBuySym1BounceDown and includeTrigBuy) or (anySellSym1BounceDown and includeTrigSell) or (anyIntraSym1BounceDown and includeTrigIntra) or (anyCalcSym1BounceDown and includeTrigPreCalc)

anySym2BounceUp = (anyPivotSym2BounceUp and includeTrigPivots) or (anyBuySym2BounceUp and includeTrigBuy) or (anySellSym2BounceUp and includeTrigSell) or (anyIntraSym2BounceUp and includeTrigIntra) or (anyCalcSym2BounceUp and includeTrigPreCalc)
anySym2BounceDown = (anyPivotSym2BounceDown and includeTrigPivots) or (anyBuySym2BounceDown and includeTrigBuy) or (anySellSym2BounceDown and includeTrigSell) or (anyIntraSym2BounceDown and includeTrigIntra) or (anyCalcSym2BounceDown and includeTrigPreCalc)

anySym1BounceUpRev = (anyPivotSym1BounceUp and includeRevPivots) or (anyBuySym1BounceUp and includeRevBuy) or (anySellSym1BounceUp and includeRevSell) or (anyIntraSym1BounceUp and includeRevIntra) or (anyCalcSym1BounceUp and includeRevPreCalc)
anySym1BounceDownRev = (anyPivotSym1BounceDown and includeRevPivots) or (anyBuySym1BounceDown and includeRevBuy) or (anySellSym1BounceDown and includeRevSell) or (anyIntraSym1BounceDown and includeRevIntra) or (anyCalcSym1BounceDown and includeRevPreCalc)

anySym2BounceUpRev = (anyPivotSym2BounceUp and includeRevPivots) or (anyBuySym2BounceUp and includeRevBuy) or (anySellSym2BounceUp and includeRevSell) or (anyIntraSym2BounceUp and includeRevIntra) or (anyCalcSym2BounceUp and includeRevPreCalc)
anySym2BounceDownRev = (anyPivotSym2BounceDown and includeRevPivots) or (anyBuySym2BounceDown and includeRevBuy) or (anySellSym2BounceDown and includeRevSell) or (anyIntraSym2BounceDown and includeRevIntra) or (anyCalcSym2BounceDown and includeRevPreCalc)

// ********** ATR RENDERING **********
dataLength = 8
atrMALength = 5
atrSmoothLength = 3
atrMultiplier = 1.0
numATR = 4
checkPastSignal = true

// ATR calculation if close is outside of ATR
[atrHMA, hl2HMA, closeHMA] = request.security(syminfo.tickerid, str.tostring(lowerTF), [ta.hma(ta.tr, numATR), hl2, close])

var upperATRRange = 0.0
upperATRRange := hl2HMA + atrMultiplier * atrHMA

var lowerATRRange = 0.0
lowerATRRange := hl2HMA + -atrMultiplier * atrHMA

var movingRange = 0.0

if closeHMA < movingRange[1]
    movingRange := upperATRRange
else
    movingRange := lowerATRRange

[curOpen, curClose] = request.security(syminfo.tickerid, str.tostring(lowerTF), [open, close])

momentum = 0
for i = 0 to dataLength by 1
    momentum += (curClose > curOpen[i] ? 1 : curClose < curOpen[i] ? -1 : 0)

momentumMA = ta.ema(momentum, atrMALength)
momentumMain = ta.ema(momentumMA, atrSmoothLength)
momentumSignal = ta.ema(momentumMain, atrSmoothLength)

currentClose = request.security(syminfo.tickerid, str.tostring(lowerTF), close)

var buyATRSignal = false
var sellATRSignal = false

if checkPastSignal
    buyATRSignal := currentClose > movingRange and (currentClose > movingRange)[1] and (currentClose > movingRange)[2] and (currentClose > movingRange)[3] and momentumMain > momentumSignal and not (momentumMain > momentumSignal)[1] and barstate.isconfirmed
    sellATRSignal := currentClose < movingRange and (currentClose < movingRange)[1] and (currentClose < movingRange)[2] and (currentClose < movingRange)[3] and momentumMain < momentumSignal and not (momentumMain < momentumSignal)[1] and barstate.isconfirmed
else
    buyATRSignal := currentClose > movingRange and momentumMain > momentumSignal ? true : false
    sellATRSignal := currentClose < movingRange and momentumMain < momentumSignal ? true : false

potentialATRLongDot = checkPastSignal ? currentClose > movingRange and (currentClose > movingRange)[1] and (currentClose > movingRange)[2] and (currentClose > movingRange)[3] and momentumMain < momentumSignal : false
potentialATRShortDot = checkPastSignal ? currentClose < movingRange and (currentClose < movingRange)[1] and (currentClose < movingRange)[2] and (currentClose < movingRange)[3] and momentumMain > momentumSignal : false

// ********** ATR RENDERING **********
plotshape(showATRArrow ? buyATRSignal and not buyATRSignal[1] : na, title="ATR Long", style=shape.triangleup, color=color.new(buyATRColor, atrArrowTransparency), location=location.belowbar, size=size.small)
plotshape(showATRArrow ? sellATRSignal and not sellATRSignal[1] : na, title="ATR Short", style=shape.triangledown, color=color.new(sellATRColor, atrArrowTransparency), location=location.abovebar, size=size.small)

plotshape(showATRDots ? potentialATRLongDot : na, title="ATR Long Forming", style=shape.circle, color=color.new(buyATRColor, atrDotTransparency), location=location.belowbar, size=size.small)
plotshape(showATRDots ? potentialATRShortDot : na, title="ATR Short Forming", style=shape.circle, color=color.new(sellATRColor, atrDotTransparency), location=location.abovebar, size=size.small)

// ********** VOLUME ANALYSIS **********
gap         = open - close[1]
    
bull_gap    = math.max(gap, 0) 
bear_gap    = math.abs(math.min(gap, 0))

body        = math.abs(close - open)
BarRange    = high - low
wick        = BarRange - body

up_bar      = close > open

bull        = wick + (up_bar ? body : 0) + bull_gap
bear        = wick + (up_bar ? 0 : body) + bear_gap
VolRange     = bull + bear
BScore      = VolRange > 0 ? bull / VolRange : 0.5
BuyVol      = BScore * volume
SellVol     = volume - BuyVol
buy_percent = (BuyVol / volume) * 100
sell_percent = (SellVol / volume) * 100

smoothBuy      = ta.wma(ta.wma(BuyVol, aveVolPeriod), volSmooth)
smoothSell     = ta.wma(ta.wma(SellVol, aveVolPeriod), volSmooth)
smoothNetVol      = smoothBuy - smoothSell

netVolH = math.max(smoothBuy, smoothSell)
netVolL = math.min(smoothBuy, smoothSell)
risingVol      = ta.change(smoothNetVol) > 0

volPumpLevel = volPumpGainLimit/100
irregVolLevel = volIrregLimit/100
regVolLevel = 60

avgVolume = ta.sma(volume, aveVolPeriod)
avgBuyVol = ta.sma(smoothBuy,aveVolPeriod)
avgSellVol = ta.sma(smoothSell,aveVolPeriod)
bullVolPump = risingVol and math.abs(smoothBuy - smoothBuy[1])/avgBuyVol > volPumpLevel  and smoothBuy > smoothSell
bullVolDump = not risingVol and math.abs(smoothSell - smoothSell[1])/avgSellVol > volPumpLevel and smoothBuy < smoothSell
midVolPump = smoothBuy > smoothSell and risingVol
midVolDump = smoothBuy < smoothSell and not risingVol
volCrossBuy = ta.crossover(smoothBuy,smoothSell)
volCrossSell = ta.crossover(smoothSell,smoothBuy)
irregVol = volume/avgVolume > irregVolLevel

deltaBuyVol = (smoothBuy - smoothBuy[1])/smoothBuy[1]
deltaSellVol = (smoothSell - smoothSell[1])/smoothSell[1]

// ********** VOLUME RENDERING **********
volColor = color.rgb(0,0,0)
volIndStyle = shape.square
if (bullVolPump)
    volColor := color.rgb(0, 255, 0)
else if (bullVolDump)
    volColor := color.rgb(255, 0, 0)
else if midVolPump
    volColor := color.rgb(0, 192, 0)
else if midVolDump
    volColor := color.rgb(192, 0, 0)
else if buy_percent > volUpperLimit
    volColor := color.rgb(0, 94, 0)
else if sell_percent > volUpperLimit
    volColor := color.rgb(94, 0, 0)

if volCrossBuy
    volIndStyle := shape.triangleup
else if volCrossSell
    volIndStyle := shape.triangledown
else if buy_percent > volTopLimit
    volIndStyle := shape.circle
else if sell_percent > volTopLimit
    volIndStyle := shape.circle
else if irregVol
    volIndStyle := shape.xcross

volCrossBuySignal = false
volCrossSellSignal = false

if volCrossBuy and barstate.isconfirmed
    volCrossBuySignal := true
    lastVolTradeDir := true

if volCrossSell and barstate.isconfirmed
    volCrossSellSignal := true
    lastVolTradeDir := false

plotshape(showVolIndicator and volColor != color.rgb(0,0,0) and volIndStyle == shape.square, title="Volume Indication", style=shape.square, color=volColor, location=location.bottom, size=size.tiny)
plotshape(showVolIndicator and volColor != color.rgb(0,0,0) and volIndStyle == shape.triangleup, title="Volume Indication", style=shape.triangleup, color=volColor, location=location.bottom, size=size.tiny, text = "Chg", textcolor = color.rgb(197, 255, 183))
plotshape(showVolIndicator and volColor != color.rgb(0,0,0) and volIndStyle == shape.triangledown, title="Volume Indication", style=shape.triangledown, color=volColor, location=location.bottom, size=size.tiny, text = "Chg", textcolor = color.rgb(255, 181, 181))
plotshape(showVolIndicator and volColor != color.rgb(0,0,0) and volIndStyle == shape.circle, title="Volume Indication", style=shape.circle, color=volColor, location=location.bottom, size=size.tiny)
plotshape(showVolIndicator and volColor != color.rgb(0,0,0) and volIndStyle == shape.xcross, title="Volume Indication", style=shape.xcross, color=volColor, location=location.bottom, size=size.tiny)

// ********** Central Chop Indicator **********
[ChopO, ChopC, ChopH, ChopL] = request.security(syminfo.tickerid, str.tostring(trendTF), [open, close, high, low])

// Direction consistency check
var bool inChopZone = false
var float upperChopZone = na
var float lowerChopZone = na
var int timeSinceChopZone = na
var bool showChopZone = false
var bool reenterChopZone = false
var bool reenterChopZoneTop = false
var bool reenterChopZoneBot = false
chopRangeTop = ChopH
chopRangeBot = ChopL
directionChange = 0
trendUp = ChopC > ChopO
chopZoneFound = false
var int tfMulti = math.max(1, math.floor(trendTF/getTimeframeInMinutes()))

for j = 1 to 5
    i = j*tfMulti
    if (trendUp)
        if (ChopC[i] < ChopO[i])
            directionChange := directionChange + 1   
    else
        if (ChopC[i] > ChopO[i])
            directionChange := directionChange + 1
            
    if (ChopC[i] < ChopO[i])
        trendUp := false
    else
        trendUp := true

    if (ChopH[i] > chopRangeTop )
        chopRangeTop := ChopH[i]
    if (ChopL[i] < chopRangeBot)
        chopRangeBot := ChopL[i]
    
    //log.info(str.tostring(ChopO[i]) + " ," + str.tostring(ChopC[i]) + " ," + str.tostring(ChopH[i]) + " ," + str.tostring(ChopL[i]) + " ," + str.tostring(directionChange) + " ," + str.tostring(tfMulti))

if (directionChange >= 3 and ChopH < chopRangeTop and ChopL > chopRangeBot and chopRangeTop - chopRangeBot < chopZoneMaxRange)
    chopZoneFound := true

if chopZoneFound and enableCentralChopZone and validTriggerPeriod
    if inChopZone == false
        inChopZone := true
        upperChopZone := chopRangeTop
        lowerChopZone := chopRangeBot
        timeSinceChopZone := 0
        showChopZone := true
        reenterChopZone := false
        reenterChopZoneTop := false
        reenterChopZoneBot := false

if inChopZone
    if high[1] > upperChopZone or low[1] < lowerChopZone
        inChopZone := false
else if enableCentralChopZone and validTriggerPeriod
    if barstate.isconfirmed
        timeSinceChopZone := timeSinceChopZone + 1
    if close > lowerChopZone and close < upperChopZone
        inChopZone := true
        reenterChopZone := true

if reenterChopZone
    if close < lowerChopZone
        reenterChopZoneBot := true
    if close > upperChopZone
        reenterChopZoneTop := true

if timeSinceChopZone > math.floor(resetChopZoneTime/getTimeframeInMinutes()) or (reenterChopZone and reenterChopZoneBot and reenterChopZoneTop)
    showChopZone := false
    reenterChopZone := false
    reenterChopZoneTop := false
    reenterChopZoneBot := false

plot(upperChopZone, "Upper Chopzone", showChopZone ? #008cff : na, 2,style = plot.style_circles)
plot(lowerChopZone, "Lower Chopzone", showChopZone ? #00ffc8 : na, 2,style = plot.style_circles)

plotshape(series=inChopZone, location=location.belowbar, color=color.rgb(187, 243, 33), style=shape.xcross, title="Chop Zone Indicator")

// ********** EMA RENDERING **********
fastMA = typeFastMA == "EMA" ? request.security(syminfo.tickerid, str.tostring(lowerTF), ta.ema(close, periodFastMA)) : request.security(syminfo.tickerid, str.tostring(lowerTF), imd(close, periodFastMA))
slowMA = typeSlowMA == "EMA" ? request.security(syminfo.tickerid, str.tostring(lowerTF), ta.ema(close, periodSlowMA)) : request.security(syminfo.tickerid, str.tostring(lowerTF), imd(close, periodSlowMA))
stableMA = typeStableMA == "EMA" ? request.security(syminfo.tickerid, str.tostring(lowerTF), ta.ema(close, periodStableMA)) : request.security(syminfo.tickerid, str.tostring(lowerTF), imd(close, periodStableMA))

// ********** EMA ANALYSIS **********
fastCrossSlowUp = ta.crossover(fastMA, slowMA) and barstate.isconfirmed
fastCrossSlowDown = ta.crossunder(fastMA, slowMA) and barstate.isconfirmed

// Chop calculation
chopCalcLength = 14
chopIndex = 100 * math.log10(math.sum(ta.atr(1), chopCalcLength) / (ta.highest(chopCalcLength) - ta.lowest(chopCalcLength))) / math.log10(chopCalcLength)
chopIndexDetect = chopIndex > 61.8

// Trend calculation
//trendDirection = direction * (trendMagnitude + momentumMagnitude + math.abs(acceleration))
trendDirection = momentumMain + (momentumMain - momentumSignal)
deltaMomentum = math.abs((momentumMA - momentumMA[1])/momentumMA)
trendColor = color.gray
volatileLimit = 5.0
trendLimit = 2.5
chopLimit = 1.5
deltaMomentumChopLimt = 0.5
deltaMomentumVolLimt = 2.5

// Set color based on trendScore
if trendDirection > volatileLimit
    trendColor := color.rgb(0, 255, 0)
else if trendDirection > trendLimit
    trendColor := color.rgb(0, 192, 0)
else if trendDirection > chopLimit
    trendColor := color.rgb(0, 94, 0)
else if trendDirection < (-1 * volatileLimit)
    trendColor := color.rgb(255, 0, 0)
else if trendDirection < (-1 * trendLimit)
    trendColor := color.rgb(192, 0, 0)
else if trendDirection < (-1 * chopLimit)
    trendColor := color.rgb(94, 0, 0)

chopDetect = (math.abs(trendDirection) < chopLimit and deltaMomentum < deltaMomentumChopLimt) or chopIndexDetect or inChopZone or inChopZone[1]
volatileMove = math.abs(trendDirection) > volatileLimit or deltaMomentum > deltaMomentumVolLimt

// Calculate adaptive line
// Using the McGinely MA
adaptiveSource = request.security(syminfo.tickerid, str.tostring(lowerTF), close)
adaptivePeriod = 8.0

if math.abs(trendDirection) > volatileLimit
    adaptivePeriod := periodFastMA
else if math.abs(trendDirection) > trendLimit
    adaptivePeriod := periodSlowMA
else
    adaptivePeriod := stableMA
    
adaptiveLine = imd(adaptiveSource, adaptivePeriod)
smoothConfirmMA = imd(adaptiveLine, confirmMASmoothPeriod)

// VWAP
vwapValue = request.security(syminfo.tickerid, str.tostring(lowerTF), ta.vwap(hlc3), barmerge.gaps_off, barmerge.lookahead_on)

// Plot MAs
plot(fastMA, color=colorFastMA, title="Fast MA")
plot(slowMA, color=colorSlowMA, title="Slow MA")
plot(stableMA, color=colorStableMA, title="Stable MA")
plot(smoothConfirmMA, title="Confirm MA", color=showConfirmMA ? trendColor : na, linewidth=2)
plot(vwapValue, title="VWAP", color=colorVWAP, linewidth=2, style=plot.style_circles)

// Check for bounce on confirmMA
bounceUpConfirm = check_bounce_low(smoothConfirmMA)
bounceDownConfirm = check_bounce_high(smoothConfirmMA)

// **********ENTRY CONDITIONS **********
priceOptimalBufferEntry =  buySellBuffer * syminfo.mintick
priceOptimalReversalEntry = reversalOffset * syminfo.mintick
priceOptimalEntryConfirm = math.abs(close - smoothConfirmMA) < priceOptimalBufferEntry

// ********** SIGNALS **********
var float limitLevel = na
buySignal = false
buyReversalSignal = false
sellSignal = false
sellReversalSignal = false
buyCrossSignal = false
sellCrossSignal = false
crossSignalLookback = math.floor(crossLookbackTime / getTimeframeInMinutes())
bufferBuySellLookback = math.floor(bounceLookbackTime / getTimeframeInMinutes())
crossATRLookback = math.floor(crossATRLookbackTime / getTimeframeInMinutes())


bool allConfluencesEnabled = not na(time(timeframe = timeframe.period, session = timePeriod1, timezone = "America/New_York"))

// If trend is up and we get a bounce up we have a buy directional else its reversal
if ticker.standard() == sym1
    // Uptrend
    if trendDirection >= chopLimit and smoothBuy > smoothSell
        if anySym1BounceUp
            buySignal := true
    else
        if anySym1BounceUpRev
            buyReversalSignal := true

    // Downtrend
    if trendDirection <= (-1 * chopLimit) and smoothBuy < smoothSell
        if anySym1BounceDown
            sellSignal := true
    else
        if anySym1BounceDownRev
            sellReversalSignal := true

// Look back over the last 2 bars to see if we had a trigger once we get a cross
if fastCrossSlowDown or sellATRSignal
    lastCrossDir := false
    for i = 0 to crossSignalLookback
        if anySym1BounceDown[i]
            sellCrossSignal := true

if fastCrossSlowDown
    for i = 0 to crossATRLookback
        if sellATRSignal[i]
            sellCrossSignal := true 

if sellATRSignal
    for i = 0 to crossATRLookback
        if fastCrossSlowDown[i]
            sellCrossSignal := true 

if fastCrossSlowUp or buyATRSignal
    lastCrossDir := true
    for i = 0 to crossSignalLookback
        if anySym1BounceUp[i] 
            buyCrossSignal := true

if fastCrossSlowUp
    for i = 0 to crossATRLookback
        if buyATRSignal[i]
            buyCrossSignal := true 

if buyATRSignal
    for i = 0 to crossATRLookback
        if fastCrossSlowUp[i]
            buyCrossSignal := true

// Volume Momentum Buy/Sell
var bool buyVolTrigger = na
var bool sellVolTrigger = na
if not chopDetect
    buyVolTrigger := (midVolPump[0] or bullVolPump[0]) and not sellVolTrigger[1]
    sellVolTrigger := (midVolDump[0] or bullVolDump[0]) and not buyVolTrigger[1]
else
    buyVolTrigger := false
    sellVolTrigger := false

bool buyTrigger = buyVolTrigger[0] and not buyVolTrigger[1] and validTriggerPeriod
bool sellTrigger = sellVolTrigger[0] and not sellVolTrigger[1] and validTriggerPeriod
bool buyVolCloseTrigger = false
bool sellVolCloseTrigger = false
var int volTradeLength = na
var bool buyVolSignal = na
var bool sellVolSignal = na
var int barsMissed = na
var int localBarsMissed = na

if (midVolDump or midVolPump)
    if deltaBuyVol < 0 and deltaSellVol < 0
        localBarsMissed := volBarsToMissNegDelta
    else if deltaBuyVol < 0 or deltaSellVol < 0
        localBarsMissed := volBarsToMissPosDelta
    else
        localBarsMissed := volBarsToMissTrade

if (validTriggerPeriod[1] and not validTriggerPeriod[0])
    if buyVolSignal
        buyVolCloseTrigger := true
    if sellVolSignal 
        sellVolCloseTrigger := true

if (buyTrigger or buyVolSignal)
    buyVolSignal := true
    limitLevel := getLimitLevel(smoothConfirmMA + priceOptimalBufferEntry, close, true)
    if barstate.isconfirmed
        volTradeLength := volTradeLength + 1
        if (midVolDump or bullVolDump) or not validTriggerPeriod
            buyVolSignal := false
            buyVolCloseTrigger := true
            volTradeLength := 0
            barsMissed := 0
        else if not (midVolPump or bullVolPump) and not volCloseOnReversalOnly
            if (barsMissed < volBarsToMissTrade)
                barsMissed := barsMissed + 1
            else
                buyVolSignal := false
                buyVolCloseTrigger := true
                volTradeLength := 0
                barsMissed := 0 
        else
            if resetBarsMissedOnLong
                barsMissed := 0    

if (sellTrigger or sellVolSignal)
    sellVolSignal := true
    limitLevel := getLimitLevel(smoothConfirmMA - priceOptimalBufferEntry, close, true)
    if barstate.isconfirmed
        volTradeLength := volTradeLength + 1
        if (midVolPump or bullVolPump) or not validTriggerPeriod
            sellVolSignal := false
            sellVolCloseTrigger := true
            volTradeLength := 0
            barsMissed := 0
        else if not (midVolDump or bullVolDump) and not volCloseOnReversalOnly
            if (barsMissed < volBarsToMissTrade)
                barsMissed := barsMissed + 1
            else
                sellVolSignal := false
                sellVolCloseTrigger := true
                volTradeLength := 0
                barsMissed := 0
        else
            if resetBarsMissedOnShort
                barsMissed := 0 

cancelSellCondition = anySym1BounceUp or fastCrossSlowUp or buyATRSignal or buyVolTrigger
cancelBuyCondition = anySym1BounceDown or fastCrossSlowDown or sellATRSignal or sellVolTrigger
// ********** DASHBOARD **********
ticker1_price  = request.security(sym1, str.tostring(lowerTF), math.round_to_mintick(close))
ticker2_price  = request.security(sym2, str.tostring(lowerTF), math.round_to_mintick(close))

// Get last close, high, and low for both tickers using the trend TF
[ticker1_TrendClose, ticker1_hlcc4, ticker1_TrendHigh, ticker1_TrendLow] = request.security(sym1, str.tostring(trendTF), [close, hlcc4, high, low])
[ticker2_TrendClose, ticker2_hlcc4, ticker2_TrendHigh, ticker2_TrendLow] = request.security(sym2, str.tostring(trendTF), [close, hlcc4, high, low])

ticker1_bgcolor = color.rgb(71, 71, 71)
ticker2_bgcolor = color.rgb(71, 71, 71)

// Check if ticker 1 is higher or lower than its last 10-minute close
if ticker1_price > ticker1_TrendHigh[1]
    ticker1_bgcolor := color.rgb(0, 190, 6)
else if ticker1_price < ticker1_TrendLow[1]
    ticker1_bgcolor := color.rgb(190, 0, 0)
else if ticker1_price > ticker1_TrendClose[1] and ticker1_price > ticker1_hlcc4[1]
    ticker1_bgcolor := color.rgb(0, 95, 3)
else if ticker1_price < ticker1_TrendClose[1] and ticker1_price < ticker1_hlcc4[1]
    ticker1_bgcolor := color.rgb(83, 0, 0)

// Check if ticker 2 is higher or lower than its last 10-minute close
if ticker2_price > ticker2_TrendHigh[1]
    ticker2_bgcolor := color.rgb(0, 190, 6)
else if ticker2_price < ticker2_TrendLow[1]
    ticker2_bgcolor := color.rgb(190, 0, 0)
else if ticker2_price > ticker2_TrendClose[1] and ticker2_price > ticker2_hlcc4[1]
    ticker2_bgcolor := color.rgb(0, 95, 3)
else if ticker2_price < ticker2_TrendClose[1] and ticker2_price < ticker2_hlcc4[1]
    ticker2_bgcolor := color.rgb(83, 0, 0)

confirmBoxColor = color.rgb(71, 71, 71)
if close - smoothConfirmMA > priceOptimalBufferEntry
    confirmBoxColor := color.rgb(0, 114, 4)
else if close - smoothConfirmMA < -1 * priceOptimalBufferEntry
    confirmBoxColor := color.rgb(116, 0, 0)

confirmToolTip = ""
if (volatileMove)
    confirmToolTip := "Volatile move in progress, caution fading this"
else if (chopDetect)
    confirmToolTip := "Market caught in chop. Advised to wait for trade"

volumePercent = 0.0
volumeColor = color.rgb(71, 71, 71)
if buy_percent > sell_percent
    volumePercent := (buy_percent - 50)*2
    if buy_percent > volTopLimit
        volumeColor := color.rgb(5, 206, 11)
    else if buy_percent > volUpperLimit
        volumeColor := color.rgb(0, 114, 4)
    else if buy_percent > regVolLevel
        volumeColor := color.rgb(0, 56, 2)
    else
        volumeColor := color.rgb(28, 0, 0)
else
    volumePercent := (sell_percent - 50)*2
    if sell_percent > volTopLimit
        volumeColor := color.rgb(206, 5, 5)
    else if sell_percent > volUpperLimit
        volumeColor := color.rgb(116, 0, 0)
    else if sell_percent > regVolLevel
        volumeColor := color.rgb(56, 0, 0)
    else
        volumeColor := color.rgb(28, 0, 0)

volumeTradeColor = color.rgb(71, 71, 71)
if buyVolSignal and bullVolPump
    volumeTradeColor := color.rgb(5, 206, 11)
else if sellVolSignal and bullVolDump
    volumeTradeColor := color.rgb(206, 5, 5)
else if buyVolSignal
    volumeTradeColor := color.rgb(0, 114, 4)
else if sellVolSignal
    volumeTradeColor := color.rgb(116, 0, 0)

// Volume Delta Shadow
var color volBGColor = na
posVolCutoff = deltaVolPosCutoff / 100
negVolCutoff = -1 * deltaVolNegCutoff / 100
if midVolPump and enableDeltaVolShadow and buyVolSignal
    if deltaBuyVol >= posVolCutoff
        if deltaSellVol >= negVolCutoff
            volBGColor := deltaVolTrendVolColor
        else
            volBGColor := deltaVolBuyVolColor
    else
        volBGColor := deltaVolNegVolColor
else if midVolDump and enableDeltaVolShadow and sellVolSignal
    if deltaSellVol >= posVolCutoff
        if deltaBuyVol >= negVolCutoff
            volBGColor := deltaVolTrendVolColor
        else
            volBGColor := deltaVolSellVolColor
    else
        volBGColor := deltaVolNegVolColor
else if buyVolCloseTrigger or sellVolCloseTrigger
    volBGColor := na

bgcolor(volBGColor)

if barstate.islast and show_table
    // Trend information
    f_fillCellColorText(0, 0, "T: " + str.tostring(math.round(trendDirection,1)), trendColor,"Shows the calculated trend index (0-10) and color. The brightest green/red indicates an aggresive up/down trend. Generally never look to short a bright green or long a bright red.")
    f_fillCellColorText(0, 1, chopDetect ? 'CHOP' : (volatileMove ? 'WARN' : ''),confirmBoxColor, "Status of price compared to the confirmation line. Ideally you want to be entering this is grey, so you are close to the confirm support. Caution taking shorts while green and longs while red as you are on the wrong side of the trend.\n\nIt will also show whether the trend is particularly volatile and risky or whether it is a chop zone")
    
    // Vol Dashboard
    if showVolDashboard
        f_fillCellColorText(1, 0, "V: " +  (lastVolTradeDir ? '▲' : '▼') + (volTradeLength != 0 ? (" | " + str.tostring(volTradeLength)) : ''), volumeTradeColor, "Shows the number of trades in one direction, as well as the last cross direction. If its green/red it shows we are in the volume trend trade. Generally you want to be onside of this trend.")
        f_fillCellColorText(1, 1, str.tostring(math.round(volumePercent,1)) + "%", volumeColor, "Show breakdown of buyers vs sellers in the volume. Scale is 0-100% both directions, with the color indicating if its buy or sell volume. The bright the color the more aggressive the volume.")

    // Symbol information
    f_fillCell(showVolDashboard ? 2 : 1, 0, extractSymbolName(sym1), "This shows the price of the ticker and the background highlight shows the trend of the ticker over the last 10.")
    f_fillCell(showVolDashboard ? 3 : 2, 0, extractSymbolName(sym2), "This shows the price of the ticker and the background highlight shows the trend of the ticker over the last 10.")        
    f_fillCellColorText(showVolDashboard ? 2 : 1, 1, str.tostring(math.round(ticker1_price,1)), ticker1_bgcolor, "HLCC4: " + str.tostring(math.round_to_mintick(ticker1_hlcc4[1])) + "\nClose: " + str.tostring(ticker1_TrendClose[1]) + "\nHigh: " + str.tostring(ticker1_TrendHigh[1]) + "\nLow: " + str.tostring(ticker1_TrendLow[1]))
    f_fillCellColorText(showVolDashboard ? 3 : 2, 1, str.tostring(math.round(ticker2_price,1)), ticker2_bgcolor, "HLCC4: " + str.tostring(math.round_to_mintick(ticker2_hlcc4[1])) + "\nClose: " + str.tostring(ticker2_TrendClose[1]) + "\nHigh: " + str.tostring(ticker2_TrendHigh[1]) + "\nLow: " + str.tostring(ticker2_TrendLow[1]))

// ********** TRADING **********
buyTriggeredInLookback = false
sellTriggeredInLookback = false
systemState := 0

buyReversalCount = 0
sellReversalCount = 0

for i = 0 to bufferBuySellLookback
    if buySignal[i]
        buyTriggeredInLookback := true
    if sellSignal[i]
        sellTriggeredInLookback := true
    if buyReversalSignal[i]
        buyTriggeredInLookback := true
        buyReversalCount += 1
    if sellSignal[i] or sellReversalSignal[i]
        sellTriggeredInLookback := true
        sellReversalCount += 1

// Make sure we get the last level in the lookback for the calcs
limitBounceLevel = 0.0
lastBounceDir = 0
for i = 0 to bufferBuySellLookback
    if bounceLevel[i] != limitBounceLevel and bounceLevel[i] > 0           
        if (buySignal[i] or buyReversalSignal[i] or buyCrossSignal[i])
            if lastBounceDir != -1
                limitBounceLevel := bounceLevel[i]
            lastBounceDir := 1
        else if sellSignal[i] or sellReversalSignal[i] or sellCrossSignal[i]
            if lastBounceDir != 1
                limitBounceLevel := bounceLevel[i]
            lastBounceDir := -1

// Check for cross buy/sell signals
buyCancelIndex = bufferBuySellLookback + 1
sellCancelIndex = bufferBuySellLookback + 1
for i = 0 to bufferBuySellLookback
    int revIndex = bufferBuySellLookback - i
    if cancelBuyCondition[revIndex]
        buyCancelIndex := revIndex
    if cancelSellCondition[revIndex]
        sellCancelIndex := revIndex
           
// Check first if we have any cancels from before
if systemState[1] > 0 and systemState[1] < 10 and cancelBuyCondition
    systemState := 0
else if systemState[1] > 10 and cancelSellCondition
    systemState := 0
else
    if not chopDetect and allConfluencesEnabled
        for i = 0 to bufferBuySellLookback
            int revIndex = bufferBuySellLookback - i
            if buyCrossSignal[revIndex] and lastCrossDir and buyCancelIndex > revIndex
                systemState := 3
                limitLevel := getLimitLevel(smoothConfirmMA + priceOptimalBufferEntry, close, true)
            else if sellCrossSignal[revIndex] and not lastCrossDir and sellCancelIndex > revIndex
                systemState := 13
                limitLevel := getLimitLevel(smoothConfirmMA - priceOptimalBufferEntry, close, false)

    // Check for buy/sell signals
    if systemState == 0
        for i = 0 to bufferBuySellLookback
            int revIndex = bufferBuySellLookback - i
            if buySignal[revIndex] and not sellTriggeredInLookback and buyCancelIndex > revIndex
                systemState := 2
                limitLevel := getLimitLevel(limitBounceLevel + priceOptimalBufferEntry, close, true)
            else if sellSignal[revIndex] and not buyTriggeredInLookback and sellCancelIndex > revIndex
                systemState := 12
                limitLevel := getLimitLevel(limitBounceLevel - priceOptimalBufferEntry, close, false)
        
    if systemState == 0
        for i = 0 to bufferBuySellLookback
            int revIndex = bufferBuySellLookback - i
            if buyReversalSignal[revIndex] and not sellTriggeredInLookback and buyCancelIndex > revIndex
                systemState := 4
                limitLevel := getLimitLevel(limitBounceLevel + priceOptimalReversalEntry, close, true)
            else if sellReversalSignal[revIndex] and not buyTriggeredInLookback and sellCancelIndex > revIndex
                systemState := 14
                limitLevel := getLimitLevel(limitBounceLevel - priceOptimalReversalEntry, close, false)

buyLong = systemState == 2
buyCross = systemState == 3
buyReversal = systemState == 4
sellShort = systemState == 12
sellCross = systemState == 13
sellReversal = systemState == 14

buyReversalTrigger = buyReversal and buyReversalCount > 1
sellReversalTrigger = sellReversal and sellReversalCount > 1

// ********** RENDERING SYMBOLS **********
if showAllConditions
    if fastCrossSlowDown 
        draw_label(bar_index, close, 'DownCross', xloc.bar_index, yloc.abovebar,  color.fuchsia, label.style_arrowdown, color.white, size.small, text.align_center, '')
    if fastCrossSlowUp 
        draw_label(bar_index, close, 'UpCross', xloc.bar_index, yloc.belowbar,  color.aqua, label.style_arrowup, color.white, size.small, text.align_center, '')
    if bounceUpConfirm and false
        draw_label(bar_index, close, 'Confirm', xloc.bar_index, yloc.belowbar,  color.green, label.style_label_up, color.white, size.small, text.align_center, '')
    if bounceDownConfirm and false
        draw_label(bar_index, close, 'Confirm', xloc.bar_index, yloc.abovebar,  color.red, label.style_label_down, color.white, size.small, text.align_center, '')
    if chopDetect
        box.new(bar_index, high, bar_index - 1, low, border_color=color.rgb(120, 120, 122, 35), border_width=1, bgcolor=color.rgb(120, 120, 122, 35), border_style=line.style_dashed)

if (buyVolCloseTrigger or sellVolCloseTrigger)
    if showVolTradeClose
        draw_label(bar_index, close, 'C', xloc.bar_index, buyVolCloseTrigger ? yloc.abovebar : yloc.belowbar,  color.rgb(110, 0, 137), buyVolCloseTrigger ? label.style_label_down: label.style_label_up, color.white, size.small, text.align_center, '')
    if alertVolTradeClose
        alert("Close Volume Trade at: " + str.tostring(limitLevel) , alert.freq_once_per_bar)
if buyTrigger and not buyVolSignal[1]
    if showVolTrade
        draw_label(bar_index, close, 'B', xloc.bar_index, yloc.belowbar,  color.rgb(0, 145, 7), label.style_label_up, color.white, size.small, text.align_center, '')
    if alertVolTrade
        alert("Volume Buy Trade at:" + str.tostring(limitLevel), alert.freq_once_per_bar)
if sellTrigger and not sellVolSignal[1]
    if showVolTrade
        draw_label(bar_index, close, 'S', xloc.bar_index, yloc.abovebar,  color.rgb(150, 1, 1), label.style_label_down, color.white, size.small, text.align_center, '')
    if alertVolTrade
        alert("Volume Sell Trade at: " + str.tostring(limitLevel), alert.freq_once_per_bar)


TP = tpLevel * syminfo.mintick
SL = slLevel * syminfo.mintick

if validTriggerPeriod
    if (systemState != systemState[1] and systemState[1] > 0 and systemState > 0 and ((systemState < 10 and systemState[1] > 10) or (systemState > 10 and systemState[1] < 10))) or (systemState[1] > 0 and systemState == 0 and ((systemState[1] > 0 and systemState[1] < 10 and cancelBuyCondition) or (systemState[1] > 10 and cancelSellCondition)))
        if showBuySellLevels
            draw_label(bar_index, limitLevel, "Close Position: " + str.tostring(systemState[1]) + "->" + str.tostring(systemState), xloc.bar_index, yloc.abovebar,  color.rgb(110, 0, 137), label.style_text_outline, color.white, size.small, text.align_center, '')
            draw_label(bar_index, close, str.tostring(close), xloc.bar_index, yloc.abovebar,  color.rgb(137, 0, 130), label.style_label_upper_left, color.white, size.tiny, text.align_center, '')
        if alertDirectionalBuySell
            alert("Close Position", alert.freq_once_per_bar)

    if buyLong
        if showBuySellLevels
            draw_buymarker(limitLevel, TP, SL)

        if alertDirectionalBuySell and not buyLong[1]
            alert("Directional Buy at: " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if buyCross
        if showBuySellLevels
            draw_buymarker(limitLevel, TP, SL)
        if alertCrossBuySell and not buyCross[1]
            alert("Cross Buy at: " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if buyReversalTrigger
        if showBuySellLevels
            draw_buymarker(limitLevel, TP, SL)
        if alertCrossBuySell and not buyReversalTrigger[1]
            alert("Reversal Buy at: " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if sellShort
        if showBuySellLevels
            draw_sellmarker(limitLevel, TP, SL)
        if alertDirectionalBuySell and not buyCross[1]
            alert("Directional Sell at: " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if sellCross
        if showBuySellLevels
            draw_sellmarker(limitLevel, TP, SL)
        if alertCrossBuySell and not sellCross[1]
            alert("Cross Sell at: " + str.tostring(limitLevel), alert.freq_once_per_bar)

    if sellReversalTrigger
        if showBuySellLevels
            draw_sellmarker(limitLevel, TP, SL)
        if alertReversalBuySell and not sellReversalTrigger[1]
            alert("Reversal Sell at: " + str.tostring(limitLevel), alert.freq_once_per_bar)


// ***** PLOT SHAPES *****
plotshape(series=close, title="Directional Long", style=shape.triangleup, location=location.bottom, color= buyLong and validTriggerPeriod  ? color.green : na, size=size.small)
plotshape(series=close, title="Reversal Long", style=shape.flag, location=location.bottom, color= buyReversalTrigger and validTriggerPeriod ? color.green : na, size=size.small)
plotshape(series=close, title="Cross Long", style=shape.labelup, location=location.bottom, color= buyCross and validTriggerPeriod  ? color.green : na, size=size.small)
plotshape(series=close, title="Directional Short", style=shape.triangledown, location=location.top, color= sellShort and validTriggerPeriod  ? color.red : na, size=size.small)
plotshape(series=close, title="Reversal Short", style=shape.flag, location=location.top, color= sellReversalTrigger and validTriggerPeriod ? color.red : na, size=size.small)
plotshape(series=close, title="Cross Short", style=shape.labeldown, location=location.top, color= sellCross and validTriggerPeriod  ? color.red : na, size=size.small)

// ********** ALERTS **********
if (anyPivotSym1Bounce or anyPivotSym2Bounce) and alertPivotsBounce
    alert("Bounce off pivot level" + (anyPivotSym1BounceUp ? " up " : " down ") + "at: " + str.tostring(math.round_to_mintick(bounceLevel)), alert.freq_once_per_bar_close)

if (anyBuySym1Bounce or anyBuySym2Bounce) and alertBuyBounce
    alert("Bounce off buy level" + (anyBuySym1BounceUp ? " up " : " down ") + " at: " + str.tostring(math.round_to_mintick(bounceLevel)), alert.freq_once_per_bar_close)

if (anySellSym1Bounce or anySellSym2Bounce) and alertSellBounce
    alert("Bounce off sell level" + (anySellSym1BounceUp ? " up " : " down ") + " at: " + str.tostring(math.round_to_mintick(bounceLevel)), alert.freq_once_per_bar_close)

if (anyIntraSym1Bounce or anyIntraSym2Bounce) and alertIntraBounce
    alert("Bounce off intra level" + (anyIntraSym1BounceUp ? " up " : " down ") + " at: "  + str.tostring(math.round_to_mintick(bounceLevel)), alert.freq_once_per_bar_close)

if (anyCalcSym1Bounce or anyCalcSym2Bounce) and alertPreCalcBounce
    alert("Bounce off calculated level" + (anyCalcSym1BounceUp ? " up " : " down ") + " at: " + str.tostring(math.round_to_mintick(bounceLevel)), alert.freq_once_per_bar_close)

if alertATRArrow
    if buyATRSignal and not buyATRSignal[1]
        alert('ATR Trigger Long on: ' + str.tostring(syminfo.ticker), alert.freq_once_per_bar_close)
    else if sellATRSignal and not sellATRSignal[1]
        alert('ATR Trigger Short on: ' + str.tostring(syminfo.ticker), alert.freq_once_per_bar_close)

if alertVolumeChange
    if volCrossSellSignal
        alert('Volume Cross Sell on: ' + str.tostring(syminfo.ticker), alert.freq_once_per_bar_close)
    else if volCrossBuySignal
        alert('Volume Cross Buy on: ' + str.tostring(syminfo.ticker), alert.freq_once_per_bar_close)

if showAllConditions
    debugText = ""
    debugText := debugText + "Trend: " + str.tostring(math.round(trendDirection,1)) + "\n"
    debugText := debugText + "Delta Momentum: " + str.tostring(math.round(deltaMomentum,2)) + "\n"
    debugText := debugText + "Chop Index: " + str.tostring(math.round(chopIndex,1)) + "%\n"
    debugText := debugText + "Volume Split[Buy/Sell]: " + str.tostring(math.round(buy_percent,1)) + "%/" + str.tostring(math.round(sell_percent,1)) + "%\n"
    if smoothBuy > smoothSell and risingVol
        debugText := debugText + "Delta Volume: " + str.tostring(math.round(math.abs(smoothBuy - smoothBuy[1])/avgBuyVol*100,2)) + "%\n"
    else if smoothBuy < smoothSell and not risingVol
        debugText := debugText + "Delta Volume: " + str.tostring(math.round(math.abs(smoothSell - smoothSell[1])/avgSellVol*100,2)) + "%\n"
    debugText := debugText + "Irregular Volume: " + str.tostring(math.round(volume/avgVolume,2)) + "%\n"
    if chopDetect or volatileMove
        debugText := debugText + "Warnings: " + (chopDetect ? "CHOP " : "") + (volatileMove ? "WARN" : "") + "\n"
    draw_label(bar_index, hlcc4, '', xloc.bar_index, yloc.price,  color.rgb(0, 0, 0), label.style_diamond, color.white, size.tiny, text.align_center, debugText)
